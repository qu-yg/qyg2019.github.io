[{"title":"AMD CMD Commonjs和ES6对比","date":"2020-02-29T03:14:43.192Z","path":"2020/02/29/AMD CMD Commonjs和ES6对比/","text":"AMD CMD Commonjs和ES6对比 AMD是RequireJS在推广过程中对模块定义规范化的产出，依赖前置，异步模块定义 CMD是SeaJS在推广过程中对模块定义规范化的产出，依赖就近，同步模块定义 CommonJS -module.exports,exports，node端使用 ES6特性 export/import","comments":true,"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.github.com/qyg2019/tags/ES6/"}]},{"title":"常用正则（传智播客总结）","date":"2020-02-15T06:19:49.029Z","path":"2020/02/15/ES6-5/","text":"一、校验数字的表达式1 数字：^[0-9]$2 n位的数字：^\\d{n}$3 至少n位的数字：^\\d{n,}$4 m-n位的数字：^\\d{m,n}$5 零和非零开头的数字：^(0|[1-9][0-9])$6 非零开头的最多带两位小数的数字：^([1-9][0-9])+(.[0-9]{1,2})?$7 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$8 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$11 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$13 非负整数：^\\d+$ 或 ^[1-9]\\d|0$14 非正整数：^-[1-9]\\d|0$ 或 ^((-\\d+)|(0+))$15 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$16 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$17 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9]*.[0-9]+)|([0-9][1-9][0-9]))$18 负浮点数：^-([1-9]\\d*.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9]*.[0-9]+)|([0-9][1-9][0-9])))$19 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d*.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式1 汉字：^[\\u4e00-\\u9fa5]{0,}$2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$3 长度为3-20的所有字符：^.{3,20}$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 三、特殊需求表达式1 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+)*.\\w+([-.]\\w+)$2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?3 InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=])?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}7 身份证号：15或18位身份证：^\\d{15}|\\d{18}$15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.[a-z])(?=.[A-Z]).{8,10}$12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9])$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9])$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})(.[0-9]{1,2})?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\\u4e00-\\u9fa5]27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\\n\\s\\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)","comments":true,"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.github.com/qyg2019/tags/ES6/"}]},{"title":"Linux基本命令(七)","date":"2020-02-14T13:23:28.747Z","path":"2020/02/14/Linux基本命令7/","text":"安装软件1$ sudo apt install 软件包 卸载软件1$ sudo apt remove 软件名 更新软件1$ sudo apt upgrade 配置软件源如果希望在 ubuntu 中安装软件, 更加快速 , 可以通过设置镜像源, 选择一个访问网速更快的服务器淘宝镜像,阿里镜像,清华镜等。","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.github.com/qyg2019/tags/Linux/"}]},{"title":"Linux基本命令(六)","date":"2020-02-14T13:17:29.789Z","path":"2020/02/14/Linux基本命令6/","text":"打包 / 解包Linux 常用 tar.gztar 是 Linux 中最常用的 备份工具. 此命令可以 把一系列文件 打包到一个大文件中, 也可以把一个 打包的大文件恢复成一系列文件 12tar -cvf 打包文件.tar 被打包的文件 &#x2F; 路径 &#x2F;&#x2F;打包文件tar -xvf 打包文件.tar &#x2F;&#x2F;解包文件 x 解开档案文件 c 生成档案文件,创建打包文件 v 列出归档解档的详细过程,显示进度 f 指定档案文件名称, f 后面一定是 .tar 文件, 所以必须放选项最后 压缩 / 解压缩gzip tar 与 gzip 命令结合可以使用实现文件 打包和压缩tar 只负责打包文件, 但不压缩 用 gzip 压缩 tar 打包后的文件, 其扩展名一般用 xxx.tar.gz 在 Linux 中, 最常见的压缩文件格式就是 xxx.tar.gz在 tar 命令中有一个选项 -z 可以调用 gzip , 从而可以方便的实现压缩和解压缩的功能 123tar -zcvf 打包文件.tar 被打包的文件 &#x2F; 路径 &#x2F;&#x2F;打包文件tar -zxvf 打包文件.tar &#x2F;&#x2F;解包文件tar -zxvf 打包文件.tar.gz -C 目标路径 &#x2F;&#x2F;解压到指定路径 bzip2 (two) tar 与 bzip2 命令结合可以实现文件 打包和压缩 (用法和 gzip 一样) ps : 扩展名一般用 : xxx.tar.bz2在 tar 命令中有一个选项 -j 可以调用 bzip2 , 从而可以方便的实现压缩和解压缩的功能 123tar -jcvf 打包文件.tar 被打包的文件 &#x2F; 路径 &#x2F;&#x2F;打包文件tar -jxvf 打包文件.tar &#x2F;&#x2F;解包文件tar -jxvf 打包文件.tar.gz -C 目标路径 &#x2F;&#x2F;解压到指定路径","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.github.com/qyg2019/tags/Linux/"}]},{"title":"Linux基本命令(五)","date":"2020-02-14T13:05:27.177Z","path":"2020/02/14/Linux基本命令5/","text":"日期和时间 磁盘信息 文件查找 软连接 查看系统时间 date 查看系统时间 cal 查看日历 磁盘信息 df -h 查看磁盘剩余空间 du - h 查看目录下文件大小 进程信息 ps aux 查看进程的详细状况 top 动态显示运行中的进程并且排序,小写q退出 kill [-9] 进程代号 终止指定代号的进程, -9表示强行终止 a 显示终端上的所有进程,包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 查找文件 find [路径] -name “.txt” 查找指定路径下扩展名是 .txt 的文件,包括子目录 软连接 ln -s 被连接的源文件链接文件 建立文件的软连接, 用通俗的方式讲 类似于 Windows 下的快捷方式 在使用 ln 创建链接时, 如果没有 -s 选项, 会创建一个 硬链接 , 而不是软连接在 Linux 中, 文件名 和 文件的数据 是分开储存的 在 Linux 中, 只有文件的 硬链接数 ==0 才会被删除, 就是说存在硬链接,即使删除了文件名,文件还在使用 ls -l 可以查看一个文件的硬链接的数量","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.github.com/qyg2019/tags/Linux/"}]},{"title":"Linux基本命令(四)","date":"2020-02-14T12:53:42.195Z","path":"2020/02/14/Linux基本命令4/","text":"用户 和 权限 的概念用户 是Linux 系统工作中中的一环, 用户管理包括 用户 和 组 管理在 Linux 系统中, 不论是由本级或是远程登录系统, 每个系统都必须有一个账号, 并且对于不同的系统资源有不同的使用权限在 Linux 中, 可以指定 每一个用户 针对 不同的文件或者目录 的不同权限对 文件 / 目录 的权限包括: 权限 缩写 代号 读 r 4 写 w 2 执行 x 1 组在实际应用中, 可以预先对 组 设置好权限, 然后 将不同的用户添加到对应的组中, 从而不用一次为每一个用户设置 修改权限chmod 简单使用 chmod 可以修改 用户 / 组 对 文件 / 目录 的权限 1$ chmod +&#x2F;-rwx 文件名|目录名 超级用户 Linux 系统中的 root 账号通常 用于系统的维护和管理 , 对操作系统的所有资源 具有所有访问权限在大多数版本的 Linux 中 , 都不推荐 直接使用 root 账号登录系统在 Linux 安装的过程中, 系统会自动创建一个用户账号, 而这个默认的用户就称为 “标准用户” sudosu 是 substitute user 的缩写, 表示 使用另一个用户的身份sudo 命令来以其他身份来执行命令, 预设的身份为 root用户使用 sudo 时,必须先输入密码, 之后有5分钟的有效期限, 超过期限则必须重新输入密码 组管理 终端命令创建组 / 删除组 的终端命令都需要通过 sudo 执行 命令 作用 groupadd 添加组 groupdel 删除组 chgrp 修改文件 / 目录的所属组 1chgrp 组名 文件 &#x2F; 目录名 修改文件 &#x2F; 目录的所属组 组信息保存在 /etc/group 文件中 创建用户 / 设置密码 / 删除用户 命令 作用 useradd -m -g 新建用户名 添加新用户 -m 自动建立用户家目录 passwd 用户名 设置用户密码 如果是普通用户, 直接用 passwd 可以修改自己的账户密码 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 创建用户时, 如果忘记添加 -m 选项指定新用户的家目录 — 最简单的方法就是删除用户, 重新创建创建用户时, 默认会创建一个和用户名同名的组名用户信息保存在 /etc/passwd 文件中 查看用户信息 命令 作用 id [用户名] 查看用户 UID 和 GID 信息 who 查看当前所有登录的用户列表 whoami 查看当前登录用户的账户名 passwd 文件 /etc/passwd 文件存放的是用户的信息, 由 6 个分号组成的 7 个信息, 分别是 用户名密码 (x, 表示加密的密码)UID (用户标识)GID (组标识)用户全名 或 本地账号家目录登录使用的 Shell , 就是登录之后, 使用的终端命令, ubuntu 默认是 dash usermod usermod 可以用来设置 用户 的 主组 / 附加组 和 登录 Shell, 命令格式如下 :主组 : 通常在新建用户时指定, 在etc / passwd 的第 4 列 GID 对应的组附加组 : 在 etc / group 中最后一列表示该组的用户列表, 用于指定 用户的附加权限 设置了用户的附加组之后, 需要重新登录才能生效 修改用户主组1usermod -g 组 用户名 修改用户附加组1usermod -G 组 用户名 修改用户登录shell1usermod -s &#x2F;bin&#x2F;bash 用户名 which查看执行命令所在位置 123which ls &#x2F;&#x2F; &#x2F;bin&#x2F;lswhich useradd &#x2F;&#x2F; &#x2F;usr&#x2F;sbin&#x2F;useradd bin 和 sbin 在 Linux 中, 绝大多数可执行文件都是保存在 /bin , /sbin , /usr/bin , /usr/sbin/bin (binary) 是二进制执行文件目录, 主要用于具体应用/sbin (system binary) 是系统管理员专用的二进制代码存放目录, 主要用于系统管理/usr/bin (user commands for applications) 后期安装的一些软件/usr/sbin (super user commands for applications) 超级用户的一些管理程序 切换用户su su -用户名 切换用户 su 不接用户名, 可以切换到 root 修改文件属性 chown 修改拥有着 chgrp 修改组 chmod 修改权限 chmod的数字表示 拥有着 组用户 其他用户 rwx rwx rwx 421 421 421 000 0 — 001 1 –x 020 2 -w- 021 3 -wx 400 4 r– 401 5 r-x 420 6 rw- 421 7 rwx 1chmod 741 文件名 | 目录名 &#x2F;&#x2F;拥有着rwx权限 组用户r--权限 其他用户x权限","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.github.com/qyg2019/tags/Linux/"}]},{"title":"Linux基本命令(三)","date":"2020-02-14T08:40:05.059Z","path":"2020/02/14/Linux基本命令3/","text":"shutdown命令可以 安全 关闭 或者 重新启动系统 命令 作用 shutdown 选项 时间 关机或重新启动 选项 作用 -r 重新启动 不指定选项和参数, 默认表示 1 分钟 之后 关闭电脑 远程维护服务器时, 最好不要关闭系统, 而应该重新启动系统 12345678910$ shutdown -r now &#x2F;&#x2F;现在重启$ shutdown now &#x2F;&#x2F;现在关机$ shutdown 20:00 &#x2F;&#x2F;20：00关机$ shutdown +10 &#x2F;&#x2F;10分钟后关机$ shutdown -c &#x2F;&#x2F;取消 ifconfig可以查看 / 配置计算机当前的网卡配置信息 1$ ifconfig | grep inet ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅, 数值越大, 速度越慢 1$ ping wwww.baidu.com &#x2F;&#x2F;或者IP地址 远程登录和远程复制文件 ssh 用户名@ip地址 登录 scp 源 目的 远程复制文件 1ssh [-p port] user@remote ssh服务器 22 web服务器 80 https 443 ftp 21 1exit &#x2F;&#x2F;退出登录 123scp -P port 123.txt user@remote:Desktop&#x2F;123.txt# 把远程 家目录下的 Desktop&#x2F;123.txt 文件 复制到 本地当前目录下的 123.txt scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中, 可以安装 PuTTY, 使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输 SSH 高级免密码登录配置别名 有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙, 一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote, 可以让远程服务器记住我们的公钥 带pub的是公钥(public) a. 客户端执行 ssh-copy-id -p port user@remote, 可以让远程服务器记住我们的公钥 ,客户端=&gt;私钥,服务端=&gt;公钥 b. 客户端发送数据给服务端时通过 私钥加密, 服务端通过 公钥解密 发送过来的数据. c. 服务端发送数据给客户端时通过 公钥解密 , 客户端通过 私钥解密 发送过来的数据. 2) 配置别名 在 ~/.ssh/config 里面追加以下内容 123456789Host mac &#x2F;&#x2F;指定别名 HostName ip地址 User 用户名 port 22","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.github.com/qyg2019/tags/Linux/"}]},{"title":"Linux基本命令(二)","date":"2020-02-14T07:54:28.185Z","path":"2020/02/14/Linux基本命令2/","text":"实用技巧敲出 命令/目录/文件 的前几个字母 , 按下 Tab 键，快速补全按 上 / 下 光标,可以再曾经使用过的命令之间来回切换.退出选择, 不执行当前命令,按 ctrl + c ls命令说明ls是list 的简写, 列出文件夹目录, ps: 用得最多的命令 Linux下文件和目录的特点： Linux 文件 或者 目录 名称最长可以有 256 个字符以 . (点)开头的文件为隐藏文件, 需要用 -a 参数才能显示 .(点) 代表当前目录 .. (两个点) 代表上一级目录 ls常用选项 -a 显示指定目录下所有子目录与文件,包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 命令 cd 命令 含义 cd 切换到当前用户的主要目录(/home/用户目录) cd ~ 切换到当前用户的主要目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 最近两个目录来回切 相对路径 在输入路径时, 最前面不是 / 或者 - ,表示相对 当前目录 所在的目录位置绝对路径 在输入路径时, 最前面是 / 或者 - ,表示从 根目录/家目录 开始的具体目录位置 mkdir创建一个新的目录 选项 含义 -p 递归创建目录 创建 mkdir -p a/b/c 命令rm删除文件或目录 使用rm删除不能恢复 选项 含义 -f 强制删除, 忽略不存在的文件, 无需提示 -r 递归地删除目录下的内容, 删除文件夹 时必须加此参数 拷贝和移动文件 tree[目录名] 以树状图列出文件目录结构 cp 源文件 目标文件 复制文件或目录 mv 源文件 目标文件 移动文件或者目录 / 文件或者目录重命名 cp选项 -f 已经存在的目标文件直接覆盖, 不会提示 -r 若给出的源文件是目录文件, 则 cp 将递归复制该目录下的所有子目录和文件,目标文件必须是一个目录名 -i 覆盖文件前提示 mv选项 -i 覆盖文件前提示 查看文件内容 命令 作用 cat 查看文件内容,创建文件,文件合并,追加文件内容等功能 more 分屏显示文件内容 grep 搜索文本文件内容 cat命令cat 会一次显示所有的内容, 适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 grep命令Linux 系统中 grep 命令是一种强大的文本搜索工具grep 允许文本文件进行 模式查找, 所谓模式查找, 又被称为正则表达式, 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行(相当于求反) -i 忽略大小写 常用的两种模式查找 参数 作用 ^a 搜寻以a 开头的行 b$ 搜寻以b 结束的行 gedit 目录名/文件名 直接打开文件","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.github.com/qyg2019/tags/Linux/"}]},{"title":"Linux基本命令(一)","date":"2020-02-14T06:57:40.743Z","path":"2020/02/14/Linux基本命令1/","text":"职场中程序员多数用到的是终端命令,而不是界面的一些东西 程序员必须掌握一些常用的终端命令 常用的命令只有 十几二十 多个 基本命令 1 ls list 查看当前文件夹下的内容 2 pwd print work direction 查看当前所在文件夹 3 cd[目录名] change direction 切换文件夹 4 touch[文件名] touch 如果文件不存在，创建文件 5 mkdir[目录名] make direction 创建目录，新建文件夹 6 rm[文件名] remove 删除指定的文件名 7 clear clear 清屏 小技巧 ctrl shift = 放大终端窗口的字体显示 ctrl - 缩小终端窗口的字体显示 终端命令的格式command [-options] parameter (选择目录 : cd 目录名称) (删除目录 : rm -r 目录名字) command : 命令名 (ls ,pwd ,clear …..)[-options] : 选项,可省略 [ ]代表可选parameter :传给命令的参数 (文件夹名等…) ####查看帮助 –help 语法 : command –help man 语法 : man command 使用man时的操作键 操作键 功能 空格 下一页内容 b 回滚一页 f 前进一页b q 退出 enter 滚动一行 文件和目录常用命令 删除操作 rm 拷贝文件 cp 移动文件 mv 查看文件内容 cat more 搜索 grep 重定向 &gt; 追加内容 &gt; &gt; 管道 |","comments":true,"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.github.com/qyg2019/tags/Linux/"}]},{"title":"扩展对象的功能性","date":"2020-02-08T12:32:39.486Z","path":"2020/02/08/ES6-4/","text":"普通对象 具有javascript对象所有默认内部行为 特异对象 具有某些与默认行为不符的内部行为 标准对象 ES6中规范中定义的对象 内建对象 脚本执行时存在于JavaScript执行环境中的对象 属性初始值，对象方法简写1234567891011121314function creat()&#123; return&#123; name, &#x2F;&#x2F;相当于 name:name age &#x2F;&#x2F;相当于 age:age &#125;&#125; var person &#x3D; &#123; sayName()&#123; &#x2F;&#x2F;函数体 &#125; &#125; 新增方法Object.is() 弥补全等运算符的不准确运算 123456789console.log(+0 &#x3D;&#x3D; -0) &#x2F;&#x2F;trueconsole.log(+0 &#x3D;&#x3D;&#x3D; -0) &#x2F;&#x2F;trueconsole.log(Object.is(+0,-0) ) &#x2F;&#x2F;falseconsole.log(NaN &#x3D;&#x3D; NaN) &#x2F;&#x2F;falseconsole.log(NaN &#x3D;&#x3D;&#x3D; NaN) &#x2F;&#x2F;falseconsole.log(Object.is(NaN,NaN)) &#x2F;&#x2F;true Object.assign() 接受任意数量的源对象，并按指定顺序将属性复制到接收对象中，排位靠后的同名属性会覆盖靠前的。 不能将提供者的访问器属性复制到接收对象中 自有属性枚举顺序 所有数字键升序排序 所有字符串按照加入顺序排序 所有symbol键按照加入顺序排序 改变对象的原型Object.getPrototypeof() 返回指定对象的原型 Object.setPrototypeof() 改变指定对象的原型 super关键字调用对象原型的方法​","comments":true,"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.github.com/qyg2019/tags/ES6/"}]},{"title":"函数","date":"2020-02-08T11:40:59.196Z","path":"2020/02/08/ES6-3/","text":"ES6中默认参数值es6简化了为形参提供默认参数值的过程，如果没有参数传入则为其提供一个初始值。 12345678function makeRequest(url, timeout &#x3D; 2000,callback &#x3D; function()&#123;&#125;)&#123; &#x2F;&#x2F;函数体&#125;makeRequest(&#39;&#x2F;foo&#39;) &#x2F;&#x2F;使用timeout callback的默认值makeRequest(&#39;&#x2F;foo&#39;，500) &#x2F;&#x2F;使用callback的默认值如果同时传入三个参数则不使用默认值，在已指定默认参数后可以继续声明无默认值参数，这种时候需要为其传入undefined才会使用其默认值。 默认参数值对arguments对象的影响 当使用默认参数值时arguments对象的行为与以往不同 arguments对象行为与ES5严格模式保持一致，默认参数值的存在使得arguments对象保持与命名参数分离, 改变first和second并不会影响arguments对象。 12345678910111213141516function args(first,second &#x3D; &#39;b&#39;)&#123; console.log(arguments.length) console.log(first &#x3D;&#x3D;&#x3D; arguments[0]) console.log(second &#x3D;&#x3D;&#x3D; arguments[1]) first &#x3D;&#39;c&#39; second &#x3D; &#39;d&#39; console.log(first &#x3D;&#x3D;&#x3D; arguments[0]) console.log(second &#x3D;&#x3D;&#x3D; arguments[1])&#125;args(&#39;a&#39;)1truefalsefalsefalse 默认参数的临时死区12345678910function add(first&#x3D;second, second)&#123; return first + second&#125;add(1,1) &#x2F;&#x2F;2add(undefined,1) &#x2F;&#x2F;抛出错误相当于let first &#x3D; secondlet second &#x3D; 1在second未初始化时访问会抛出错误 不定参数在函数命名参数前添加 … 就表明这是一个不定参数，该参数为一个数组，通过数组名即可一一访问里面的参数。 每个函数最多只能声明一个不定参数 一定要放在所有参数的末尾 不定参数不能用于对象字面量setter之中 无论 是否使用不定参数，arguments对象总是包含传入函数的所有参数 展开运算符将数组打散后作为独立的参数传入函数 12let values &#x3D; [25,70,50,100]console.log(Math.max(...values)) &#x2F;&#x2F;100 name属性所有函数的name属性都有一个合适的值。 123456789101112function doSomething()&#123; &#x2F;&#x2F;&#125;function doSomethingElse()&#123; &#x2F;&#x2F;&#125; console.log(doSomething.name) &#x2F;&#x2F;doSomethingconsole.log(doSomethingElse.name) &#x2F;&#x2F;doSomethingElse getter 和 setter函数中name属性有 get 和 set前缀 通过bind()函数创建的函数有bound前缀 通过Function创建的函数带有anonymous前缀 不能用name属性来获取对于函数的引用 ​ javascript函数有两个不同的内部方法： [[Call]] 和 [[Construct]] 。通过new关键字调用函数时执行的是 [[Construct]] 函数，负责创建实例对象，然后在执行函数体，将this绑定到实例上，如果不通过new关键字调用则执行 [[Call]]方法，具有 [[Construct]] 方法的函数称为构造函数。 判断函数被调用的方法ES5中用instanceof 12345678910function Person(name)&#123;if(this instanceof Person)&#123; this.name &#x3D; name&#125;else&#123; throw new error(&#39;必须通过new调用&#39;)&#125;&#125;var person &#x3D; new Person（&#39;nike&#39;）var person1 &#x3D; Person（&#39;nike&#39;） &#x2F;&#x2F;抛出错误 这个方法不可靠，Person.call(), Person.apply()也可以将this绑定到Person的实例上 ES6引入元属性new.target解决这个问题 当调用[[Construct]] 方法时，new.target被赋值为new操作符的目标,通常是新创建对象实例 当调用 [[Call]]方法时，new.target被赋值为undefined 可以通过new.target__是否被定义__来安全地检测函数是否通过new关键字来调用。 箭头函数 没有this，super，arguments，new.target绑定，这些值有外围最近一层非箭头函数觉得 不能通过new关键字调用 没有原型 不可以改变this的绑定 不支持arguments对象 不支持重复的命名参数 语法为 123456789101112131415let reflect &#x3D; value &#x3D;&gt; value &#x2F;&#x2F; 只有一个参数时相当于let reflect &#x3D; function(value)&#123; return value&#125;let sum &#x3D; (num1,num2) &#x3D;&gt; num1 + num2 &#x2F;&#x2F;两个或两个以上参数时相当于let sum &#x3D; function(num1,num2)&#123; return num1+num2&#125;如果需要返回对象字面量，需将其包裹在&#123;&#125;里let getItem &#x3D; id &#x3D;&gt;(&#123;id:id,name:&quot;temp&quot;&#125;) 尾调用优化尾调用指的是函数作为另一个函数的最后一条语句调用。 123456function doSomething()&#123; ... return doSomethingElse()&#125; 尾调用不访问当前栈帧的变量，也就是说函数不是一个闭包 在函数内部，尾调用时最后一条语句 尾调用的结果作为函数值返回","comments":true,"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.github.com/qyg2019/tags/ES6/"}]},{"title":"字符串和正则表达式","date":"2020-02-04T06:49:43.884Z","path":"2020/02/04/ES6-2/","text":"codePointAt()方法ES6新增完全支持UTF-16的方法，接受编码单元位置而非字符位置作为参数，返回对应位置的码位。 String.fromCodePoint()方法根据指定码位生成一个字符。 normalize()方法提供Unicode的标准化形式 。接受一个可选的字符串参数。 NFC 默认选项 NFD NFKC NFKD 在进行排序和比较操作前，将被操作字符串按照同一标准进行标准化。 正则表达式u修饰符为一个正则表达式添加u修饰符，就从编码操作模式切换为字符模式，就不会视代理对为两个字符。 flags属性返回当前正则表达式的修饰字符串 reg 123let reg &#x3D; &#x2F;ab&#x2F;gconsole.log(reg.flags) &#x2F;&#x2F;gconsole.log(reg.source) &#x2F;&#x2F;ab 其他字符串变更 includes() ​ 在字符串中检测到指定文本返回true startswith() ​ 在字符串的起始部分检测到指定文本返回true endswith() 在字符串的起始部分检测到指定文本返回true 以上的方法都接受两个参数，第二个参数是可选的，如果指定了第二个参数，includes()，startswith()会从这个位置开始匹配，endswith()会从字符串长度减去这个位置开始匹配。 repeat()方法 ​ 接受一个number类型的参数，表示该字符串重复的次数。 模板字面量 多行字符串 1234let msg &#x3D; &#96;multilinestring&#96;console.log(msg) &#x2F;&#x2F;multiline &#x2F;&#x2F;string ​ 字符串占位符${} 123let name &#x3D; &quot;jobs&quot;let msg &#x3D; &quot;hello,$&#123;name&#125;&quot;console.log(msg) &#x2F;&#x2F; hello,jobs ​ ​ 可以把任何合法的javascript表达式嵌入到占位符中作为字符串的一部分输出到结果中 标签模板 ​ 它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串","comments":true,"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.github.com/qyg2019/tags/ES6/"}]},{"title":"块级作用域绑定","date":"2020-01-23T07:14:38.757Z","path":"2020/01/23/ES6-1/","text":"var声明及变量提升（hoisting机制）在函数作用域或者全局作用域中通过var声明的变量，无论在哪里声明的，都会被当成是在当前作用域顶部声明的变量，这就是hoisting机制。ES6引入块级作用域来强化对变量生命周期的控制。 块级声明块级声明在指定块的作用域之外无法访问的变量。 函数内部 块中（{}之间的区域） 1. let声明 用let来代替var声明变量，把变量的作用域限制在当前代码块，let声明不会被提升，当执行流离开当前块，变量会立刻被销毁。 禁止重声明 a12var a&#x3D;1;let a&#x3D;2; &#x2F;&#x2F;抛出语法错误 2. const声明 const声明的是常量，其值一旦被设定后不可更改 使用const声明的常量必须初始化，常量同样不会被提升到作用域顶部 块外执行即刻被销毁 禁止重声明 const声明不允许修改绑定，但可以修改值，可以修改声明对象的值 临时死区（TDZ）JavaScript引擎在扫描代码发现变量声明时，要么将变量提升至作用域顶部，要么放到TDZ中访问TDZ中的变量会触发运行时错误。当执行过变量声明语句后，从TDZ中移出，然后才可正常访问。 var与let，const全局作用域绑定的区别当var被用于全局作用域时，会创建一个新的全局变量作为全局对象window的属性，这可能会覆盖一个已经存在的全局变量。 使用let, const会在全局作用域下创建一个新的绑定，但不会添加为全局对象的属性，不能覆盖全局变量，只能遮盖。","comments":true,"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.github.com/qyg2019/tags/ES6/"}]},{"title":"vue实例的生命周期","date":"2020-01-12T04:50:36.899Z","path":"2020/01/12/vue生命周期/","text":"VUE实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"webpack使用","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/webpack/","text":"在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑：1234567&#x2F;&#x2F; 导入jquery类库 import $ from &#39;jquery&#39; &#x2F;&#x2F; 设置偶数行背景色，索引从0开始，0是偶数 $(&#39;#list li:even&#39;).css(&#39;backgroundColor&#39;,&#39;lightblue&#39;); &#x2F;&#x2F; 设置奇数行背景色 $(&#39;#list li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src&#x2F;js&#x2F;main.js dist&#x2F;bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011&#x2F;&#x2F; 导入处理路径的模块var path &#x3D; require(&#39;path&#39;);&#x2F;&#x2F; 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports &#x3D; &#123; entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件 output: &#123; &#x2F;&#x2F; 配置输出选项 path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径 filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名 &#125;&#125; 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1&quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot; 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下：123456789101112131415161718&#x2F;&#x2F; 导入处理路径的模块var path &#x3D; require(&#39;path&#39;);&#x2F;&#x2F; 导入自动生成HTMl文件的插件var htmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);module.exports &#x3D; &#123; entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件 output: &#123; &#x2F;&#x2F; 配置输出选项 path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径 filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名 &#125;, plugins:[ &#x2F;&#x2F; 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &#39;src&#x2F;index.html&#39;),&#x2F;&#x2F;模板路径 filename:&#39;index.html&#39;&#x2F;&#x2F;自动生成的HTML文件的名称 &#125;) ]&#125; 修改package.json中script节点中的dev指令如下：1&quot;dev&quot;: &quot;webpack-dev-server&quot; 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot; 方式2： 修改webpack.config.js文件，新增devServer节点如下：12345devServer:&#123; hot:true, open:true, port:4321 &#125; 在头部引入webpack模块：1var webpack &#x3D; require(&#39;webpack&#39;); 在plugins节点下新增：1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件：12345module: &#123; &#x2F;&#x2F; 用来配置第三方loader模块的 rules: [ &#x2F;&#x2F; 文件的匹配规则 &#123; test: &#x2F;\\.css$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] &#125;&#x2F;&#x2F;处理css文件的规则 ] &#125; 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1&#123; test: &#x2F;\\.less$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] &#125;, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1&#123; test: &#x2F;\\.scss$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] &#125; 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块：1&#123; test: &#x2F;\\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader&#39; &#125; 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：1&#123; test: &#x2F;\\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader?limit&#x3D;43960&#39; &#125;, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项：1&#123; test: &#x2F;\\.js$&#x2F;, use: &#39;babel-loader&#39;, exclude: &#x2F;node_modules&#x2F; &#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下：1234&#123; &quot;presets&quot;:[&quot;es2015&quot;, &quot;stage-0&quot;], &quot;plugins&quot;:[&quot;transform-runtime&quot;]&#125; 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法；","comments":true,"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.github.com/qyg2019/tags/webpack/"}]},{"title":"图解MVVM与MVC","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/图解MVVM与MVC/","text":"MVC与MVVCMVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。Controller（控制器）是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVVMModel 模型模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 View 视图就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。 ViewModel 视图模型视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。","comments":true,"tags":[{"name":"MVVM与MVC","slug":"MVVM与MVC","permalink":"https://www.github.com/qyg2019/tags/MVVM%E4%B8%8EMVC/"}]},{"title":"vue组件的使用","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/组件的使用/","text":"定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法： 1234var login &#x3D; Vue.extend(&#123; template: &#39;&lt;h1&gt;登录&lt;&#x2F;h1&gt;&#39; &#125;); Vue.component(&#39;login&#39;, login); 直接使用 Vue.component 方法： 123Vue.component(&#39;register&#39;, &#123; template: &#39;&lt;h1&gt;注册&lt;&#x2F;h1&gt;&#39; &#125;); 将模板字符串，定义到script标签种： 123&lt;script id&#x3D;&quot;tmpl&quot; type&#x3D;&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;#&quot;&gt;注册&lt;&#x2F;a&gt;&lt;&#x2F;div&gt; &lt;&#x2F;script&gt; 同时，需要使用 Vue.component 来定义组件： 123Vue.component(&#39;account&#39;, &#123; template: &#39;#tmpl&#39; &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component(&#39;account&#39;, &#123; template: &#39;#tmpl&#39;, data() &#123; return &#123; msg: &#39;大家好！&#39; &#125; &#125;, methods:&#123; login()&#123; alert(&#39;点击了登录按钮&#39;); &#125; &#125; &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 为什么组件中的data属性必须定义为一个方法并返回一个对象保持一份单独的拷贝。 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; &#x2F;&#x2F; 定义子组件 account: &#123; &#x2F;&#x2F; account 组件 template: &#39;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;&lt;login&gt;&lt;&#x2F;login&gt;&lt;&#x2F;div&gt;&#39;, &#x2F;&#x2F; 在这里使用定义的子组件 components: &#123; &#x2F;&#x2F; 定义子组件的子组件 login: &#123; &#x2F;&#x2F; login 组件 template: &quot;&lt;h3&gt;这是登录组件&lt;&#x2F;h3&gt;&quot; &#125; &#125; &#125; &#125; &#125;); &lt;&#x2F;script&gt; 引用组件： 123&lt;div id&#x3D;&quot;app&quot;&gt; &lt;account&gt;&lt;&#x2F;account&gt; &lt;&#x2F;div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;toggle&quot; @click&#x3D;&quot;flag&#x3D;!flag&quot;&gt; &lt;my-com1 v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com1&gt; &lt;my-com2 v-else&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com2&gt; &lt;&#x2F;div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component(&#39;myCom1&#39;, &#123; template: &#39;&lt;h3&gt;奔波霸&lt;&#x2F;h3&gt;&#39; &#125;) Vue.component(&#39;myCom2&#39;, &#123; template: &#39;&lt;h3&gt;霸波奔&lt;&#x2F;h3&gt;&#39; &#125;) &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;&#x2F;script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122&#x2F;&#x2F; 登录组件 const login &#x3D; Vue.extend(&#123; template: &#96;&lt;div&gt; &lt;h3&gt;登录组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&#96; &#125;); Vue.component(&#39;login&#39;, login); &#x2F;&#x2F; 注册组件 const register &#x3D; Vue.extend(&#123; template: &#96;&lt;div&gt; &lt;h3&gt;注册组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&#96; &#125;); Vue.component(&#39;register&#39;, register); &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; comName: &#39;login&#39; &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id&#x3D;&quot;app&quot;&gt; &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;login&#39;&quot;&gt;登录&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;register&#39;&quot;&gt;注册&lt;&#x2F;a&gt; &lt;hr&gt; &lt;transition mode&#x3D;&quot;out-in&quot;&gt; &lt;component :is&#x3D;&quot;comName&quot;&gt;&lt;&#x2F;component&gt; &lt;&#x2F;transition&gt;&lt;&#x2F;div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;&#x2F;style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; msg: &#39;这是父组件中的消息&#39; &#125;, components: &#123; son: &#123; template: &#39;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;&#x2F;h1&gt;&#39;, props: [&#39;finfo&#39;] &#125; &#125; &#125;); &lt;&#x2F;script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id&#x3D;&quot;app&quot;&gt; &lt;son :finfo&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt; &lt;&#x2F;div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id&#x3D;&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type&#x3D;&quot;x-template&quot; id&#x3D;&quot;son&quot;&gt; &lt;div&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;向父组件传值&quot; @click&#x3D;&quot;sendMsg&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;script&gt; &lt;&#x2F;div&gt; &lt;script&gt; &#x2F;&#x2F; 子组件的定义方式 Vue.component(&#39;son&#39;, &#123; template: &#39;#son&#39;, &#x2F;&#x2F; 组件模板Id methods: &#123; sendMsg() &#123; &#x2F;&#x2F; 按钮的点击事件 this.$emit(&#39;func&#39;, &#39;OK&#39;); &#x2F;&#x2F; 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123; getMsg(val)&#123; &#x2F;&#x2F; 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;&#x2F;script&gt;","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"配置Git","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/配置Git/","text":"为了设置Git中的配置值，需要使用config命令。 告知Git你的身份这要根据用户名和电子邮件地址来确定，Git是一个源管理系统，它期望知道是谁在进行这些变更，以方便记录。 git config–global user.name git config–global user.email 实际上Git可以接受任何邮件地址，在设置时并不会对其进行验证，但是Git的一些高级功能可能会使用这个邮件地址，因此保证其正确性还是很有必要的。 配置范围 system 在系统级别配置意味着会被应用于指定机器上所有仓库。用config命令指定–system选项。 git config–system global 全局配置值适用于特定用户的所有仓库，这是用户适用最常见的级别。 git config–global local 该设置只用于一个仓库的上下文。 git config–local 设置的层次结构首先会在本地仓库配置中查找，然后查找全局配置，最后查找系统配置。如果找到一个值，那么就是用这个值。 查看配置值 git config 撤销配置值 git config –unset 列出配置值 git config –list 包含但不限于本地，全局，系统，如果同时设置将会一起显示，为了避免混淆，可以指定范围。 git config –global –list 一次性配置 git -c = 类似于键值对的形式 ​","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"分布式版本控制系统Git常用命令浅谈","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/git分布式命令浅谈/","text":"什么是Git Git下载地址Git是目前世界上最先进的分布式版本控制系统,具有备份， 记录操作时间线，多端共享代码（代替各种云盘的功能），‘自动’合并的功能。Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容基本是完全一样的。 Git原理及基本操作 本地仓库分为工作区、缓冲区以及仓库,每个仓库可以简单理解成一个目录，这个目录里面的所有文件都通过Git来实现版本管理，Git都能跟踪并记录在该目录中发生的所有更新。 安装好Git后，新建一个文件夹，单击右键gitbush,输入以下命令初始化一个本地仓库： 可以看到出现了一个文件夹： 接下来就可以在这个文件夹中进行开发了。 一顿苦逼的开发之后…… 使用add命令将指定文件或全部文件推入缓冲区​ ​ 使用commit命令推入本地仓库​ 至此一个版本开发完毕，当然git还提供更多命令来供用户操作，一起来了解下吧！ git status： 查看仓库当前的状态 ​ git diff +文件名：查看文件具体修改了哪里 ​ git log：查看最近到最远提交到仓库的文件信息(一串数字为特有的时间序列id 可以根据它进行版本前后回滚) git reset –hard HEAD^：回退到上一次 commit的时候 git reset –hard bdeacd: 版本前进 只能根据 id进行前进（id只写出前六位就好了） git reflog：查看每次操作仓库内的信息（commit）这样的话当黑窗口没了的时候，也可以查询具体操作信息， 进行版本回退或者前进! git checkout – read.txt: 工作区恢复到最近一次的commit或者add git rm +文件名: 删除某一个文件 需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。 git branch dev: 创建dev分支 git checkout dev： 切换到dev分支上开发 git branch：查看所有分支 git branch -d dev：删除分支 （-D 强制删除） git merge dev: 合并分支 在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作：1. 首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）2.可以通过git clone远程仓库（git clone git@github.com:HustCst/duyiApp.git）或者通过git remote add origin git@github.com:HustCst/duyiApp.git，是本地仓库和远程仓库相关联，git pull origin master，本地才有master分支！3.之后再本地master分支上的代码上传到 远程仓库上的master分支 第一次上传使用 git push –u origin master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过 git push origin master –f 强行让master分支上的本地文件覆盖远程master分支上的文件）ps:切记不要在本地master分支上开发，在其他分支如dev上开发后，合并到master上直接上传到 远程的 非master分支如dev分支，通过 git push origin master:dev; 之后项目参与者可以 new pull request 进行代码比对和阅读，项目管理人员在同意的情况下，会把远程dev分支上的东西合并到远程master分支上。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"vue-resource的使用","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/vue-resource/","text":"vue-resource的使用 Vue 要实现异步加载需要使用到 vue-resource 库。 Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。 vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 常见的请求：get post jsonp​ get请求 this.$http.get(url).then( function(res){}, function(err){} ) ​ post请求 this.$http.post( url, {}, { emulateJSON: true }).then( function(res){}, function(err){} ) ​ jsonp请求 this.$http.jsonp(url).then( function(res){}, function(err){} ) 注：post 发送数据到后端，需要第三个参数 {emulateJSON:true} 。vue-resource共提供七种请求方法 参数说明： ​ 处理响应的方法：","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"vue指令学习","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/vue指令/","text":"框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlv-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 Vue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 注意： v-model 只能运用在 表单元素中 在Vue中使用样式使用class样式 数组 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt; 数组中使用三元表达式 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 数组中嵌套对象 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 直接使用对象 1&lt;h1 :class&#x3D;&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是H1&lt;&#x2F;h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style&#x3D;&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是的H1&lt;&#x2F;h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：123data: &#123; h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;h1StyleObj&quot;&gt;这是H1&lt;&#x2F;h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：1234data: &#123; h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;, h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是H1&lt;&#x2F;h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for&#x3D;&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for&#x3D;&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;&#x2F;div&gt; 迭代数字 12&lt;p v-for&#x3D;&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;&#x2F;p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-showv-if 的特点：每次都会重新删除或创建元素 v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 v-if 有较高的切换性能消耗v-show 有较高的初始渲染消耗 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"移动内容的核心Git命令","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/git核心命令/","text":"从 到 命令 注解 工作目录 暂存区域 add 暂存本地变更 暂存区域 本地仓库 commit 仅提交暂存区域内容 本地仓库 远程仓库 push 在推送时同步内容 本地仓库 工作目录 checkout 切换当前分支 远程仓库 本地环境 clone 创建本地仓库和工作目录 远程仓库 本地仓库 fetch 更新远程分支的引用 远程仓库 本地仓库和工作目录 pull 抓取合并到本地分支和工作目录","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"Git升级模型","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/git/","text":"工作目录本地系统上的任何目录或目录树都可以成为Git仓库的工作目录。工作目录可以拥有形成一个整体工作区的任意数量的子目录。在将Git连接到本地目录树时，会创建一个仓库框架，也就是本地仓库（默认情况下本地仓库为.git） 可以通过–git-dir或者一个环境变量$GIT_DIR来重写git的默认位置。 暂存区域一个在变更被提交到本地仓库之前暂存变更的地方，保存已经从工作目录升级了的任意内容的集合。 两种使用场景： 1.准备场景 用户在工作区中完成变更，将文件移动到暂存区中，支持任意力度，甚至可以一个一个文件升级。 2.修复场景 拉取仓库中最后一次提交，更新其内容，推送会前一次提交的位置。 3.处理合并冲突 将无法解决的冲突放入工作目录中，暂存那些被干净合并的文件，待冲突解决后，暂存区包含一组完整的解决冲突后的文件，提交到本地仓库。 可以绕过暂存区吗？ 仅适用于Git已经在追踪的文件，这意味着文件首次被添加到Git时，必须经历暂存阶段。 本地仓库本地环境上Git级别的最后一个部分，通过两种方式来创建： 1.远程仓库的一份克隆 2.告知Git在本地初始化一个新环境 它是当前用户独占使用的一个源仓库，用户在对内容感到满意之前，都可以进行修改，之后可以将内容发送到远程仓库。如果工作目录被意外清除并且未同步到远程，那么内容将会丢失。如果其他人持续更新特定的远程仓库，那么从本地仓库将内容同步到远程仓库之间时间间隔越长，出现合并问题的概率越高。 远程仓库多个Git用户从各自本地仓库向上同步变更的地方。 远程仓库是唯一的，对于多个项目而言，可以有许多远程仓库，但不会再服务器生成或使用远程仓库的多个副本 可以根据需要将远程仓库多次克隆到不同的本地仓库","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"vue动画","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/animate/","text":"Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构：1234567&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;动起来&quot; @click&#x3D;&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name&#x3D;&quot;fade&quot;&gt; &lt;div v-show&#x3D;&quot;show&quot;&gt;动画&lt;&#x2F;div&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt; VM 实例：123456789101112&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModelvar vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; show: false &#125;, methods: &#123; myAnimate() &#123; this.isshow &#x3D; !this.isshow; &#125; &#125;&#125;); 定义两组类样式：12345678910111213&#x2F;* 定义进入和离开时候的过渡状态 *&#x2F; .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; &#x2F;* 定义进入过渡的开始状态 和 离开过渡的结束状态 *&#x2F; .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库：1&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;.&#x2F;lib&#x2F;animate.css&quot;&gt; 定义 transition 及属性：123456&lt;transition enter-active-class&#x3D;&quot;fadeInRight&quot; leave-active-class&#x3D;&quot;fadeOutRight&quot; :duration&#x3D;&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt; &lt;div class&#x3D;&quot;animated&quot; v-show&#x3D;&quot;isshow&quot;&gt;动画&lt;&#x2F;div&gt;&lt;&#x2F;transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数：123456789&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;切换动画&quot; @click&#x3D;&quot;show &#x3D; !show&quot;&gt; &lt;transition @before-enter&#x3D;&quot;beforeEnter&quot; @enter&#x3D;&quot;enter&quot; @after-enter&#x3D;&quot;afterEnter&quot;&gt; &lt;div v-if&#x3D;&quot;show&quot; class&#x3D;&quot;shows&quot;&gt;OK&lt;&#x2F;div&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt; 定义三个 methods 钩子方法：12345678910111213methods: &#123; beforeEnter(el) &#123; &#x2F;&#x2F; 动画进入之前的回调 el.style.transform &#x3D; &#39;translateX(500px)&#39;; &#125;, enter(el, done) &#123; &#x2F;&#x2F; 动画进入完成时候的回调 el.offsetWidth; el.style.transform &#x3D; &#39;translateX(0px)&#39;; done(); &#125;, afterEnter(el) &#123; &#x2F;&#x2F; 动画进入完成之后的回调 this.show &#x3D; !this.show; &#125; &#125; 定义动画过渡时长和样式：123.shows&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式：123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;&#x2F;style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：1234567&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;txt&quot; @keyup.enter&#x3D;&quot;add&quot;&gt; &lt;transition-group tag&#x3D;&quot;ul&quot; name&#x3D;&quot;list&quot;&gt; &lt;li v-for&#x3D;&quot;(item, i) in list&quot; :key&#x3D;&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;transition-group&gt;&lt;&#x2F;div&gt; 定义 VM中的结构：1234567891011121314&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModelvar vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; txt: &#39;&#39;, list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt &#x3D; &#39;&#39;; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125;","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]}]