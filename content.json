[{"title":"VUE组件的使用","date":"2019-12-25T14:07:38.867Z","path":"2019/12/25/组件的使用/","text":"定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法： 1var login &#x3D; Vue.extend(&#123;2 template: &#39;&lt;h1&gt;登录&lt;&#x2F;h1&gt;&#39;3 &#125;);4 Vue.component(&#39;login&#39;, login); 直接使用 Vue.component 方法： 1Vue.component(&#39;register&#39;, &#123;2 template: &#39;&lt;h1&gt;注册&lt;&#x2F;h1&gt;&#39;3 &#125;); 将模板字符串，定义到script标签种： 1&lt;script id&#x3D;&quot;tmpl&quot; type&#x3D;&quot;x-template&quot;&gt;2 &lt;div&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;#&quot;&gt;注册&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;3 &lt;&#x2F;script&gt; 同时，需要使用 Vue.component 来定义组件： 1Vue.component(&#39;account&#39;, &#123;2 template: &#39;#tmpl&#39;3 &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 1Vue.component(&#39;account&#39;, &#123;2 template: &#39;#tmpl&#39;,3 data() &#123;4 return &#123;5 msg: &#39;大家好！&#39;6 &#125;7 &#125;,8 methods:&#123;9 login()&#123;10 alert(&#39;点击了登录按钮&#39;);11 &#125;12 &#125;13 &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 为什么组件中的data属性必须定义为一个方法并返回一个对象保持一份单独的拷贝。 使用components属性定义局部子组件 组件实例定义方式： 1&lt;script&gt;2 &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel3 var vm &#x3D; new Vue(&#123;4 el: &#39;#app&#39;,5 data: &#123;&#125;,6 methods: &#123;&#125;,7 components: &#123; &#x2F;&#x2F; 定义子组件8 account: &#123; &#x2F;&#x2F; account 组件9 template: &#39;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;&lt;login&gt;&lt;&#x2F;login&gt;&lt;&#x2F;div&gt;&#39;, &#x2F;&#x2F; 在这里使用定义的子组件10 components: &#123; &#x2F;&#x2F; 定义子组件的子组件11 login: &#123; &#x2F;&#x2F; login 组件12 template: &quot;&lt;h3&gt;这是登录组件&lt;&#x2F;h3&gt;&quot;13 &#125;14 &#125;15 &#125;16 &#125;17 &#125;);18 &lt;&#x2F;script&gt; 引用组件： 1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;account&gt;&lt;&#x2F;account&gt;3 &lt;&#x2F;div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;toggle&quot; @click&#x3D;&quot;flag&#x3D;!flag&quot;&gt;3 &lt;my-com1 v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com1&gt;4 &lt;my-com2 v-else&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com2&gt;5 &lt;&#x2F;div&gt; Vue实例定义： 1&lt;script&gt;2 Vue.component(&#39;myCom1&#39;, &#123;3 template: &#39;&lt;h3&gt;奔波霸&lt;&#x2F;h3&gt;&#39;4 &#125;)56 Vue.component(&#39;myCom2&#39;, &#123;7 template: &#39;&lt;h3&gt;霸波奔&lt;&#x2F;h3&gt;&#39;8 &#125;)910 &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel11 var vm &#x3D; new Vue(&#123;12 el: &#39;#app&#39;,13 data: &#123;14 flag: true15 &#125;,16 methods: &#123;&#125;17 &#125;);18 &lt;&#x2F;script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 1&#x2F;&#x2F; 登录组件2 const login &#x3D; Vue.extend(&#123;3 template: &#96;&lt;div&gt;4 &lt;h3&gt;登录组件&lt;&#x2F;h3&gt;5 &lt;&#x2F;div&gt;&#96;6 &#125;);7 Vue.component(&#39;login&#39;, login);89 &#x2F;&#x2F; 注册组件10 const register &#x3D; Vue.extend(&#123;11 template: &#96;&lt;div&gt;12 &lt;h3&gt;注册组件&lt;&#x2F;h3&gt;13 &lt;&#x2F;div&gt;&#96;14 &#125;);15 Vue.component(&#39;register&#39;, register);1617 &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel18 var vm &#x3D; new Vue(&#123;19 el: &#39;#app&#39;,20 data: &#123; comName: &#39;login&#39; &#125;,21 methods: &#123;&#125;22 &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;login&#39;&quot;&gt;登录&lt;&#x2F;a&gt;3 &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;register&#39;&quot;&gt;注册&lt;&#x2F;a&gt;4 &lt;hr&gt;5 &lt;transition mode&#x3D;&quot;out-in&quot;&gt;6 &lt;component :is&#x3D;&quot;comName&quot;&gt;&lt;&#x2F;component&gt;7 &lt;&#x2F;transition&gt;8&lt;&#x2F;div&gt; 添加切换样式： 1&lt;style&gt;2 .v-enter,3 .v-leave-to &#123;4 opacity: 0;5 transform: translateX(30px);6 &#125;78 .v-enter-active,9 .v-leave-active &#123;10 position: absolute;11 transition: all 0.3s ease;12 &#125;1314 h3&#123;15 margin: 0;16 &#125;17&lt;&#x2F;style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 1&lt;script&gt;2 &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel3 var vm &#x3D; new Vue(&#123;4 el: &#39;#app&#39;,5 data: &#123;6 msg: &#39;这是父组件中的消息&#39;7 &#125;,8 components: &#123;9 son: &#123;10 template: &#39;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;&#x2F;h1&gt;&#39;,11 props: [&#39;finfo&#39;]12 &#125;13 &#125;14 &#125;);15 &lt;&#x2F;script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;son :finfo&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt;3 &lt;&#x2F;div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;!-- 引用父组件 --&gt;3 &lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;45 &lt;!-- 组件模板定义 --&gt;6 &lt;script type&#x3D;&quot;x-template&quot; id&#x3D;&quot;son&quot;&gt;7 &lt;div&gt;8 &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;向父组件传值&quot; @click&#x3D;&quot;sendMsg&quot; &#x2F;&gt;9 &lt;&#x2F;div&gt;10 &lt;&#x2F;script&gt;11 &lt;&#x2F;div&gt;1213 &lt;script&gt;14 &#x2F;&#x2F; 子组件的定义方式15 Vue.component(&#39;son&#39;, &#123;16 template: &#39;#son&#39;, &#x2F;&#x2F; 组件模板Id17 methods: &#123;18 sendMsg() &#123; &#x2F;&#x2F; 按钮的点击事件19 this.$emit(&#39;func&#39;, &#39;OK&#39;); &#x2F;&#x2F; 调用父组件传递过来的方法，同时把数据传递出去20 &#125;21 &#125;22 &#125;);2324 &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel25 var vm &#x3D; new Vue(&#123;26 el: &#39;#app&#39;,27 data: &#123;&#125;,28 methods: &#123;29 getMsg(val)&#123; &#x2F;&#x2F; 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义30 alert(val);31 &#125;32 &#125;33 &#125;);34 &lt;&#x2F;script&gt;","comments":true,"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.github.com/qyg2019/tags/VUE/"}]},{"title":"VUE动画","date":"2019-12-21T07:23:58.126Z","path":"2019/12/21/animate/","text":"Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构：1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;动起来&quot; @click&#x3D;&quot;myAnimate&quot;&gt;3 &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;4 &lt;transition name&#x3D;&quot;fade&quot;&gt;5 &lt;div v-show&#x3D;&quot;show&quot;&gt;动画&lt;&#x2F;div&gt;6 &lt;&#x2F;transition&gt;7 &lt;&#x2F;div&gt; VM 实例：1&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel2var vm &#x3D; new Vue(&#123;3 el: &#39;#app&#39;,4 data: &#123;5 show: false6 &#125;,7 methods: &#123;8 myAnimate() &#123;9 this.isshow &#x3D; !this.isshow;10 &#125;11 &#125;12&#125;); 定义两组类样式：1&#x2F;* 定义进入和离开时候的过渡状态 *&#x2F;2 .fade-enter-active,3 .fade-leave-active &#123;4 transition: all 0.2s ease;5 position: absolute;6 &#125;78 &#x2F;* 定义进入过渡的开始状态 和 离开过渡的结束状态 *&#x2F;9 .fade-enter,10 .fade-leave-to &#123;11 opacity: 0;12 transform: translateX(100px);13 &#125; 使用第三方 CSS 动画库 导入动画类库：1&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;.&#x2F;lib&#x2F;animate.css&quot;&gt; 定义 transition 及属性：1&lt;transition2 enter-active-class&#x3D;&quot;fadeInRight&quot;3 leave-active-class&#x3D;&quot;fadeOutRight&quot;4 :duration&#x3D;&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;5 &lt;div class&#x3D;&quot;animated&quot; v-show&#x3D;&quot;isshow&quot;&gt;动画&lt;&#x2F;div&gt;6&lt;&#x2F;transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数：1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;切换动画&quot; @click&#x3D;&quot;show &#x3D; !show&quot;&gt;3 &lt;transition4 @before-enter&#x3D;&quot;beforeEnter&quot;5 @enter&#x3D;&quot;enter&quot;6 @after-enter&#x3D;&quot;afterEnter&quot;&gt;7 &lt;div v-if&#x3D;&quot;show&quot; class&#x3D;&quot;shows&quot;&gt;OK&lt;&#x2F;div&gt;8 &lt;&#x2F;transition&gt;9 &lt;&#x2F;div&gt; 定义三个 methods 钩子方法：1methods: &#123;2 beforeEnter(el) &#123; &#x2F;&#x2F; 动画进入之前的回调3 el.style.transform &#x3D; &#39;translateX(500px)&#39;;4 &#125;,5 enter(el, done) &#123; &#x2F;&#x2F; 动画进入完成时候的回调6 el.offsetWidth;7 el.style.transform &#x3D; &#39;translateX(0px)&#39;;8 done();9 &#125;,10 afterEnter(el) &#123; &#x2F;&#x2F; 动画进入完成之后的回调11 this.show &#x3D; !this.show;12 &#125;13 &#125; 定义动画过渡时长和样式：1.shows&#123;2 transition: all 0.4s ease;3 &#125; v-for 的列表过渡 定义过渡样式：1&lt;style&gt;2 .list-enter,3 .list-leave-to &#123;4 opacity: 0;5 transform: translateY(10px);6 &#125;78 .list-enter-active,9 .list-leave-active &#123;10 transition: all 0.3s ease;11 &#125;12&lt;&#x2F;style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：1&lt;div id&#x3D;&quot;app&quot;&gt;2 &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;txt&quot; @keyup.enter&#x3D;&quot;add&quot;&gt;34 &lt;transition-group tag&#x3D;&quot;ul&quot; name&#x3D;&quot;list&quot;&gt;5 &lt;li v-for&#x3D;&quot;(item, i) in list&quot; :key&#x3D;&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;6 &lt;&#x2F;transition-group&gt;7&lt;&#x2F;div&gt; 定义 VM中的结构：1&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel2var vm &#x3D; new Vue(&#123;3 el: &#39;#app&#39;,4 data: &#123;5 txt: &#39;&#39;,6 list: [1, 2, 3, 4]7 &#125;,8 methods: &#123;9 add() &#123;10 this.list.push(this.txt);11 this.txt &#x3D; &#39;&#39;;12 &#125;13 &#125;14&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：1.v-move&#123;2 transition: all 0.8s ease;3&#125;4.v-leave-active&#123;5 position: absolute;6&#125;","comments":true,"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.github.com/qyg2019/tags/VUE/"}]},{"title":"vue-resource的使用","date":"2019-12-17T12:42:29.657Z","path":"2019/12/17/vue-resource/","text":"vue-resource的使用 Vue 要实现异步加载需要使用到 vue-resource 库。 Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。 vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 常见的请求：get post jsonp​ get请求 this.$http.get(url).then( function(res){}, function(err){} ) ​ post请求 this.$http.post( url, {}, { emulateJSON: true }).then( function(res){}, function(err){} ) ​ jsonp请求 this.$http.jsonp(url).then( function(res){}, function(err){} ) 注：post 发送数据到后端，需要第三个参数 {emulateJSON:true} 。vue-resource共提供七种请求方法 参数说明： ​ 处理响应的方法：","comments":true,"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.github.com/qyg2019/tags/VUE/"}]},{"title":"VUE实例的生命周期","date":"2019-12-16T11:22:26.274Z","path":"2019/12/16/vue生命周期/","text":"VUE实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。","comments":true,"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.github.com/qyg2019/tags/VUE/"}]},{"title":"配置Git","date":"2019-12-15T11:34:00.459Z","path":"2019/12/15/配置Git/","text":"为了设置Git中的配置值，需要使用config命令。 告知Git你的身份这要根据用户名和电子邮件地址来确定，Git是一个源管理系统，它期望知道是谁在进行这些变更，以方便记录。 git config–global user.name git config–global user.email 实际上Git可以接受任何邮件地址，在设置时并不会对其进行验证，但是Git的一些高级功能可能会使用这个邮件地址，因此保证其正确性还是很有必要的。 配置范围 system 在系统级别配置意味着会被应用于指定机器上所有仓库。用config命令指定–system选项。 git config–system global 全局配置值适用于特定用户的所有仓库，这是用户适用最常见的级别。 git config–global local 该设置只用于一个仓库的上下文。 git config–local 设置的层次结构首先会在本地仓库配置中查找，然后查找全局配置，最后查找系统配置。如果找到一个值，那么就是用这个值。 查看配置值 git config 撤销配置值 git config –unset 列出配置值 git config –list 包含但不限于本地，全局，系统，如果同时设置将会一起显示，为了避免混淆，可以指定范围。 git config –global –list 一次性配置 git -c = 类似于键值对的形式 ​","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"移动内容的核心Git命令","date":"2019-12-13T12:31:28.949Z","path":"2019/12/13/git核心命令/","text":"从 到 命令 注解 工作目录 暂存区域 add 暂存本地变更 暂存区域 本地仓库 commit 仅提交暂存区域内容 本地仓库 远程仓库 push 在推送时同步内容 本地仓库 工作目录 checkout 切换当前分支 远程仓库 本地环境 clone 创建本地仓库和工作目录 远程仓库 本地仓库 fetch 更新远程分支的引用 远程仓库 本地仓库和工作目录 pull 抓取合并到本地分支和工作目录","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"Git升级模型","date":"2019-12-13T09:09:53.859Z","path":"2019/12/13/git/","text":"工作目录本地系统上的任何目录或目录树都可以成为Git仓库的工作目录。工作目录可以拥有形成一个整体工作区的任意数量的子目录。在将Git连接到本地目录树时，会创建一个仓库框架，也就是本地仓库（默认情况下本地仓库为.git） 可以通过–git-dir或者一个环境变量$GIT_DIR来重写git的默认位置。 暂存区域一个在变更被提交到本地仓库之前暂存变更的地方，保存已经从工作目录升级了的任意内容的集合。 两种使用场景： 1.准备场景 用户在工作区中完成变更，将文件移动到暂存区中，支持任意力度，甚至可以一个一个文件升级。 2.修复场景 拉取仓库中最后一次提交，更新其内容，推送会前一次提交的位置。 3.处理合并冲突 将无法解决的冲突放入工作目录中，暂存那些被干净合并的文件，待冲突解决后，暂存区包含一组完整的解决冲突后的文件，提交到本地仓库。 可以绕过暂存区吗？ 仅适用于Git已经在追踪的文件，这意味着文件首次被添加到Git时，必须经历暂存阶段。 本地仓库本地环境上Git级别的最后一个部分，通过两种方式来创建： 1.远程仓库的一份克隆 2.告知Git在本地初始化一个新环境 它是当前用户独占使用的一个源仓库，用户在对内容感到满意之前，都可以进行修改，之后可以将内容发送到远程仓库。如果工作目录被意外清除并且未同步到远程，那么内容将会丢失。如果其他人持续更新特定的远程仓库，那么从本地仓库将内容同步到远程仓库之间时间间隔越长，出现合并问题的概率越高。 远程仓库多个Git用户从各自本地仓库向上同步变更的地方。 远程仓库是唯一的，对于多个项目而言，可以有许多远程仓库，但不会再服务器生成或使用远程仓库的多个副本 可以根据需要将远程仓库多次克隆到不同的本地仓库","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"图解MVVM与MVC","date":"2019-12-11T13:29:58.626Z","path":"2019/12/11/图解MVVM与MVC/","text":"MVC与MVVCMVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。Controller（控制器）是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVVMModel 模型模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 View 视图就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。 ViewModel 视图模型视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。","comments":true,"tags":[{"name":"MVVM与MVC","slug":"MVVM与MVC","permalink":"https://www.github.com/qyg2019/tags/MVVM%E4%B8%8EMVC/"}]},{"title":"VUE指令学习","date":"2019-12-11T11:34:58.773Z","path":"2019/12/11/vue指令/","text":"框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlv-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 Vue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 注意： v-model 只能运用在 表单元素中 在Vue中使用样式使用class样式 数组 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt; 数组中使用三元表达式 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 数组中嵌套对象 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 直接使用对象 1&lt;h1 :class&#x3D;&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是H1&lt;&#x2F;h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style&#x3D;&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是的H1&lt;&#x2F;h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：1data: &#123;2 h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;3&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;h1StyleObj&quot;&gt;这是H1&lt;&#x2F;h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：1data: &#123;2 h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;,3 h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;4&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是H1&lt;&#x2F;h1&gt; Vue指令之v-for和key属性 迭代数组 1&lt;ul&gt;2 &lt;li v-for&#x3D;&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;3&lt;&#x2F;ul&gt; 迭代对象中的属性 12&lt;!-- 循环遍历对象身上的属性 --&gt;34 &lt;div v-for&#x3D;&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;&#x2F;div&gt; 迭代数字 12&lt;p v-for&#x3D;&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;&#x2F;p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-showv-if 的特点：每次都会重新删除或创建元素 v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 v-if 有较高的切换性能消耗v-show 有较高的初始渲染消耗 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。","comments":true,"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.github.com/qyg2019/tags/VUE/"}]},{"title":"分布式版本控制系统Git常用命令浅谈","date":"2019-11-30T12:10:21.813Z","path":"2019/11/30/git分布式命令浅谈/","text":"什么是Git Git下载地址Git是目前世界上最先进的分布式版本控制系统,具有备份， 记录操作时间线，多端共享代码（代替各种云盘的功能），‘自动’合并的功能。Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容基本是完全一样的。 Git原理及基本操作 本地仓库分为工作区、缓冲区以及仓库,每个仓库可以简单理解成一个目录，这个目录里面的所有文件都通过Git来实现版本管理，Git都能跟踪并记录在该目录中发生的所有更新。 安装好Git后，新建一个文件夹，单击右键gitbush,输入以下命令初始化一个本地仓库： 可以看到出现了一个文件夹： 接下来就可以在这个文件夹中进行开发了。 一顿苦逼的开发之后…… 使用add命令将指定文件或全部文件推入缓冲区​ ​ 使用commit命令推入本地仓库​ 至此一个版本开发完毕，当然git还提供更多命令来供用户操作，一起来了解下吧！ git status： 查看仓库当前的状态 ​ git diff +文件名：查看文件具体修改了哪里 ​ git log：查看最近到最远提交到仓库的文件信息(一串数字为特有的时间序列id 可以根据它进行版本前后回滚) git reset –hard HEAD^：回退到上一次 commit的时候 git reset –hard bdeacd: 版本前进 只能根据 id进行前进（id只写出前六位就好了） git reflog：查看每次操作仓库内的信息（commit）这样的话当黑窗口没了的时候，也可以查询具体操作信息， 进行版本回退或者前进! git checkout – read.txt: 工作区恢复到最近一次的commit或者add git rm +文件名: 删除某一个文件 需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。 git branch dev: 创建dev分支 git checkout dev： 切换到dev分支上开发 git branch：查看所有分支 git branch -d dev：删除分支 （-D 强制删除） git merge dev: 合并分支 在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作：1. 首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）2.可以通过git clone远程仓库（git clone git@github.com:HustCst/duyiApp.git）或者通过git remote add origin git@github.com:HustCst/duyiApp.git，是本地仓库和远程仓库相关联，git pull origin master，本地才有master分支！3.之后再本地master分支上的代码上传到 远程仓库上的master分支 第一次上传使用 git push –u origin master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过 git push origin master –f 强行让master分支上的本地文件覆盖远程master分支上的文件）ps:切记不要在本地master分支上开发，在其他分支如dev上开发后，合并到master上直接上传到 远程的 非master分支如dev分支，通过 git push origin master:dev; 之后项目参与者可以 new pull request 进行代码比对和阅读，项目管理人员在同意的情况下，会把远程dev分支上的东西合并到远程master分支上。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]}]