[{"title":"webpack使用","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/webpack/","text":"在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 什么是webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的2种解决方案 使用Gulp， 是基于 task 任务的； 使用Webpack， 是基于整个项目进行构建的； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍webpack打包的过程 webpack安装的两种方式 运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用webpack打包构建列表隔行变色案例 运行npm init初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装jquery类库 创建main.js并书写各行变色的代码逻辑：1234567&#x2F;&#x2F; 导入jquery类库 import $ from &#39;jquery&#39; &#x2F;&#x2F; 设置偶数行背景色，索引从0开始，0是偶数 $(&#39;#list li:even&#39;).css(&#39;backgroundColor&#39;,&#39;lightblue&#39;); &#x2F;&#x2F; 设置奇数行背景色 $(&#39;#list li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理：1webpack src&#x2F;js&#x2F;main.js dist&#x2F;bundle.js 使用webpack的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径：1234567891011&#x2F;&#x2F; 导入处理路径的模块var path &#x3D; require(&#39;path&#39;);&#x2F;&#x2F; 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports &#x3D; &#123; entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件 output: &#123; &#x2F;&#x2F; 配置输出选项 path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径 filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名 &#125;&#125; 实现webpack的实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问webpack-dev-server启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录：1&quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot; 同时修改index页面中script的src属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下：123456789101112131415161718&#x2F;&#x2F; 导入处理路径的模块var path &#x3D; require(&#39;path&#39;);&#x2F;&#x2F; 导入自动生成HTMl文件的插件var htmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);module.exports &#x3D; &#123; entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件 output: &#123; &#x2F;&#x2F; 配置输出选项 path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径 filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名 &#125;, plugins:[ &#x2F;&#x2F; 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &#39;src&#x2F;index.html&#39;),&#x2F;&#x2F;模板路径 filename:&#39;index.html&#39;&#x2F;&#x2F;自动生成的HTML文件的名称 &#125;) ]&#125; 修改package.json中script节点中的dev指令如下：1&quot;dev&quot;: &quot;webpack-dev-server&quot; 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！ 方式1： 修改package.json的script节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为4321，--hot表示启用浏览器热更新：1&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot; 方式2： 修改webpack.config.js文件，新增devServer节点如下：12345devServer:&#123; hot:true, open:true, port:4321 &#125; 在头部引入webpack模块：1var webpack &#x3D; require(&#39;webpack&#39;); 在plugins节点下新增：1new webpack.HotModuleReplacementPlugin() 使用webpack打包css文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件：12345module: &#123; &#x2F;&#x2F; 用来配置第三方loader模块的 rules: [ &#x2F;&#x2F; 文件的匹配规则 &#123; test: &#x2F;\\.css$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] &#125;&#x2F;&#x2F;处理css文件的规则 ] &#125; 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序是从后向前调用的； 使用webpack打包less文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件：1&#123; test: &#x2F;\\.less$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] &#125;, 使用webpack打包sass文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理sass文件的loader模块：1&#123; test: &#x2F;\\.scss$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] &#125; 使用webpack处理css中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块：1&#123; test: &#x2F;\\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader&#39; &#125; 可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：1&#123; test: &#x2F;\\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader?limit&#x3D;43960&#39; &#125;, 使用babel处理高级JS语法 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev安装babel的相关loader包 运行cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev安装babel转换的语法 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项：1&#123; test: &#x2F;\\.js$&#x2F;, use: &#39;babel-loader&#39;, exclude: &#x2F;node_modules&#x2F; &#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下：1234&#123; &quot;presets&quot;:[&quot;es2015&quot;, &quot;stage-0&quot;], &quot;plugins&quot;:[&quot;transform-runtime&quot;]&#125; 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的ES相关的语法；","comments":true,"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.github.com/qyg2019/tags/webpack/"}]},{"title":"vue组件的使用","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/组件的使用/","text":"定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法： 1234var login &#x3D; Vue.extend(&#123; template: &#39;&lt;h1&gt;登录&lt;&#x2F;h1&gt;&#39; &#125;); Vue.component(&#39;login&#39;, login); 直接使用 Vue.component 方法： 123Vue.component(&#39;register&#39;, &#123; template: &#39;&lt;h1&gt;注册&lt;&#x2F;h1&gt;&#39; &#125;); 将模板字符串，定义到script标签种： 123&lt;script id&#x3D;&quot;tmpl&quot; type&#x3D;&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;#&quot;&gt;注册&lt;&#x2F;a&gt;&lt;&#x2F;div&gt; &lt;&#x2F;script&gt; 同时，需要使用 Vue.component 来定义组件： 123Vue.component(&#39;account&#39;, &#123; template: &#39;#tmpl&#39; &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component(&#39;account&#39;, &#123; template: &#39;#tmpl&#39;, data() &#123; return &#123; msg: &#39;大家好！&#39; &#125; &#125;, methods:&#123; login()&#123; alert(&#39;点击了登录按钮&#39;); &#125; &#125; &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 为什么组件中的data属性必须定义为一个方法并返回一个对象保持一份单独的拷贝。 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; &#x2F;&#x2F; 定义子组件 account: &#123; &#x2F;&#x2F; account 组件 template: &#39;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;&lt;login&gt;&lt;&#x2F;login&gt;&lt;&#x2F;div&gt;&#39;, &#x2F;&#x2F; 在这里使用定义的子组件 components: &#123; &#x2F;&#x2F; 定义子组件的子组件 login: &#123; &#x2F;&#x2F; login 组件 template: &quot;&lt;h3&gt;这是登录组件&lt;&#x2F;h3&gt;&quot; &#125; &#125; &#125; &#125; &#125;); &lt;&#x2F;script&gt; 引用组件： 123&lt;div id&#x3D;&quot;app&quot;&gt; &lt;account&gt;&lt;&#x2F;account&gt; &lt;&#x2F;div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;toggle&quot; @click&#x3D;&quot;flag&#x3D;!flag&quot;&gt; &lt;my-com1 v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com1&gt; &lt;my-com2 v-else&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com2&gt; &lt;&#x2F;div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component(&#39;myCom1&#39;, &#123; template: &#39;&lt;h3&gt;奔波霸&lt;&#x2F;h3&gt;&#39; &#125;) Vue.component(&#39;myCom2&#39;, &#123; template: &#39;&lt;h3&gt;霸波奔&lt;&#x2F;h3&gt;&#39; &#125;) &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;&#x2F;script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122&#x2F;&#x2F; 登录组件 const login &#x3D; Vue.extend(&#123; template: &#96;&lt;div&gt; &lt;h3&gt;登录组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&#96; &#125;); Vue.component(&#39;login&#39;, login); &#x2F;&#x2F; 注册组件 const register &#x3D; Vue.extend(&#123; template: &#96;&lt;div&gt; &lt;h3&gt;注册组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&#96; &#125;); Vue.component(&#39;register&#39;, register); &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; comName: &#39;login&#39; &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id&#x3D;&quot;app&quot;&gt; &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;login&#39;&quot;&gt;登录&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;register&#39;&quot;&gt;注册&lt;&#x2F;a&gt; &lt;hr&gt; &lt;transition mode&#x3D;&quot;out-in&quot;&gt; &lt;component :is&#x3D;&quot;comName&quot;&gt;&lt;&#x2F;component&gt; &lt;&#x2F;transition&gt;&lt;&#x2F;div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;&#x2F;style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; msg: &#39;这是父组件中的消息&#39; &#125;, components: &#123; son: &#123; template: &#39;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;&#x2F;h1&gt;&#39;, props: [&#39;finfo&#39;] &#125; &#125; &#125;); &lt;&#x2F;script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id&#x3D;&quot;app&quot;&gt; &lt;son :finfo&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt; &lt;&#x2F;div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id&#x3D;&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type&#x3D;&quot;x-template&quot; id&#x3D;&quot;son&quot;&gt; &lt;div&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;向父组件传值&quot; @click&#x3D;&quot;sendMsg&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;script&gt; &lt;&#x2F;div&gt; &lt;script&gt; &#x2F;&#x2F; 子组件的定义方式 Vue.component(&#39;son&#39;, &#123; template: &#39;#son&#39;, &#x2F;&#x2F; 组件模板Id methods: &#123; sendMsg() &#123; &#x2F;&#x2F; 按钮的点击事件 this.$emit(&#39;func&#39;, &#39;OK&#39;); &#x2F;&#x2F; 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123; getMsg(val)&#123; &#x2F;&#x2F; 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;&#x2F;script&gt;","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"图解MVVM与MVC","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/图解MVVM与MVC/","text":"MVC与MVVCMVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。Controller（控制器）是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVVMModel 模型模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 View 视图就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。 ViewModel 视图模型视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。","comments":true,"tags":[{"name":"MVVM与MVC","slug":"MVVM与MVC","permalink":"https://www.github.com/qyg2019/tags/MVVM%E4%B8%8EMVC/"}]},{"title":"配置Git","date":"2020-01-05T11:40:54.038Z","path":"2020/01/05/配置Git/","text":"为了设置Git中的配置值，需要使用config命令。 告知Git你的身份这要根据用户名和电子邮件地址来确定，Git是一个源管理系统，它期望知道是谁在进行这些变更，以方便记录。 git config–global user.name git config–global user.email 实际上Git可以接受任何邮件地址，在设置时并不会对其进行验证，但是Git的一些高级功能可能会使用这个邮件地址，因此保证其正确性还是很有必要的。 配置范围 system 在系统级别配置意味着会被应用于指定机器上所有仓库。用config命令指定–system选项。 git config–system global 全局配置值适用于特定用户的所有仓库，这是用户适用最常见的级别。 git config–global local 该设置只用于一个仓库的上下文。 git config–local 设置的层次结构首先会在本地仓库配置中查找，然后查找全局配置，最后查找系统配置。如果找到一个值，那么就是用这个值。 查看配置值 git config 撤销配置值 git config –unset 列出配置值 git config –list 包含但不限于本地，全局，系统，如果同时设置将会一起显示，为了避免混淆，可以指定范围。 git config –global –list 一次性配置 git -c = 类似于键值对的形式 ​","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"vue动画","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/animate/","text":"Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构：1234567&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;动起来&quot; @click&#x3D;&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name&#x3D;&quot;fade&quot;&gt; &lt;div v-show&#x3D;&quot;show&quot;&gt;动画&lt;&#x2F;div&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt; VM 实例：123456789101112&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModelvar vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; show: false &#125;, methods: &#123; myAnimate() &#123; this.isshow &#x3D; !this.isshow; &#125; &#125;&#125;); 定义两组类样式：12345678910111213&#x2F;* 定义进入和离开时候的过渡状态 *&#x2F; .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; &#x2F;* 定义进入过渡的开始状态 和 离开过渡的结束状态 *&#x2F; .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库：1&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;.&#x2F;lib&#x2F;animate.css&quot;&gt; 定义 transition 及属性：123456&lt;transition enter-active-class&#x3D;&quot;fadeInRight&quot; leave-active-class&#x3D;&quot;fadeOutRight&quot; :duration&#x3D;&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt; &lt;div class&#x3D;&quot;animated&quot; v-show&#x3D;&quot;isshow&quot;&gt;动画&lt;&#x2F;div&gt;&lt;&#x2F;transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数：123456789&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;切换动画&quot; @click&#x3D;&quot;show &#x3D; !show&quot;&gt; &lt;transition @before-enter&#x3D;&quot;beforeEnter&quot; @enter&#x3D;&quot;enter&quot; @after-enter&#x3D;&quot;afterEnter&quot;&gt; &lt;div v-if&#x3D;&quot;show&quot; class&#x3D;&quot;shows&quot;&gt;OK&lt;&#x2F;div&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt; 定义三个 methods 钩子方法：12345678910111213methods: &#123; beforeEnter(el) &#123; &#x2F;&#x2F; 动画进入之前的回调 el.style.transform &#x3D; &#39;translateX(500px)&#39;; &#125;, enter(el, done) &#123; &#x2F;&#x2F; 动画进入完成时候的回调 el.offsetWidth; el.style.transform &#x3D; &#39;translateX(0px)&#39;; done(); &#125;, afterEnter(el) &#123; &#x2F;&#x2F; 动画进入完成之后的回调 this.show &#x3D; !this.show; &#125; &#125; 定义动画过渡时长和样式：123.shows&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式：123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;&#x2F;style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：1234567&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;txt&quot; @keyup.enter&#x3D;&quot;add&quot;&gt; &lt;transition-group tag&#x3D;&quot;ul&quot; name&#x3D;&quot;list&quot;&gt; &lt;li v-for&#x3D;&quot;(item, i) in list&quot; :key&#x3D;&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;transition-group&gt;&lt;&#x2F;div&gt; 定义 VM中的结构：1234567891011121314&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModelvar vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; txt: &#39;&#39;, list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt &#x3D; &#39;&#39;; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125;","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"移动内容的核心Git命令","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/git核心命令/","text":"从 到 命令 注解 工作目录 暂存区域 add 暂存本地变更 暂存区域 本地仓库 commit 仅提交暂存区域内容 本地仓库 远程仓库 push 在推送时同步内容 本地仓库 工作目录 checkout 切换当前分支 远程仓库 本地环境 clone 创建本地仓库和工作目录 远程仓库 本地仓库 fetch 更新远程分支的引用 远程仓库 本地仓库和工作目录 pull 抓取合并到本地分支和工作目录","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"Git升级模型","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/git/","text":"工作目录本地系统上的任何目录或目录树都可以成为Git仓库的工作目录。工作目录可以拥有形成一个整体工作区的任意数量的子目录。在将Git连接到本地目录树时，会创建一个仓库框架，也就是本地仓库（默认情况下本地仓库为.git） 可以通过–git-dir或者一个环境变量$GIT_DIR来重写git的默认位置。 暂存区域一个在变更被提交到本地仓库之前暂存变更的地方，保存已经从工作目录升级了的任意内容的集合。 两种使用场景： 1.准备场景 用户在工作区中完成变更，将文件移动到暂存区中，支持任意力度，甚至可以一个一个文件升级。 2.修复场景 拉取仓库中最后一次提交，更新其内容，推送会前一次提交的位置。 3.处理合并冲突 将无法解决的冲突放入工作目录中，暂存那些被干净合并的文件，待冲突解决后，暂存区包含一组完整的解决冲突后的文件，提交到本地仓库。 可以绕过暂存区吗？ 仅适用于Git已经在追踪的文件，这意味着文件首次被添加到Git时，必须经历暂存阶段。 本地仓库本地环境上Git级别的最后一个部分，通过两种方式来创建： 1.远程仓库的一份克隆 2.告知Git在本地初始化一个新环境 它是当前用户独占使用的一个源仓库，用户在对内容感到满意之前，都可以进行修改，之后可以将内容发送到远程仓库。如果工作目录被意外清除并且未同步到远程，那么内容将会丢失。如果其他人持续更新特定的远程仓库，那么从本地仓库将内容同步到远程仓库之间时间间隔越长，出现合并问题的概率越高。 远程仓库多个Git用户从各自本地仓库向上同步变更的地方。 远程仓库是唯一的，对于多个项目而言，可以有许多远程仓库，但不会再服务器生成或使用远程仓库的多个副本 可以根据需要将远程仓库多次克隆到不同的本地仓库","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"分布式版本控制系统Git常用命令浅谈","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/git分布式命令浅谈/","text":"什么是Git Git下载地址Git是目前世界上最先进的分布式版本控制系统,具有备份， 记录操作时间线，多端共享代码（代替各种云盘的功能），‘自动’合并的功能。Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容基本是完全一样的。 Git原理及基本操作 本地仓库分为工作区、缓冲区以及仓库,每个仓库可以简单理解成一个目录，这个目录里面的所有文件都通过Git来实现版本管理，Git都能跟踪并记录在该目录中发生的所有更新。 安装好Git后，新建一个文件夹，单击右键gitbush,输入以下命令初始化一个本地仓库： 可以看到出现了一个文件夹： 接下来就可以在这个文件夹中进行开发了。 一顿苦逼的开发之后…… 使用add命令将指定文件或全部文件推入缓冲区​ ​ 使用commit命令推入本地仓库​ 至此一个版本开发完毕，当然git还提供更多命令来供用户操作，一起来了解下吧！ git status： 查看仓库当前的状态 ​ git diff +文件名：查看文件具体修改了哪里 ​ git log：查看最近到最远提交到仓库的文件信息(一串数字为特有的时间序列id 可以根据它进行版本前后回滚) git reset –hard HEAD^：回退到上一次 commit的时候 git reset –hard bdeacd: 版本前进 只能根据 id进行前进（id只写出前六位就好了） git reflog：查看每次操作仓库内的信息（commit）这样的话当黑窗口没了的时候，也可以查询具体操作信息， 进行版本回退或者前进! git checkout – read.txt: 工作区恢复到最近一次的commit或者add git rm +文件名: 删除某一个文件 需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。 git branch dev: 创建dev分支 git checkout dev： 切换到dev分支上开发 git branch：查看所有分支 git branch -d dev：删除分支 （-D 强制删除） git merge dev: 合并分支 在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作：1. 首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）2.可以通过git clone远程仓库（git clone git@github.com:HustCst/duyiApp.git）或者通过git remote add origin git@github.com:HustCst/duyiApp.git，是本地仓库和远程仓库相关联，git pull origin master，本地才有master分支！3.之后再本地master分支上的代码上传到 远程仓库上的master分支 第一次上传使用 git push –u origin master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过 git push origin master –f 强行让master分支上的本地文件覆盖远程master分支上的文件）ps:切记不要在本地master分支上开发，在其他分支如dev上开发后，合并到master上直接上传到 远程的 非master分支如dev分支，通过 git push origin master:dev; 之后项目参与者可以 new pull request 进行代码比对和阅读，项目管理人员在同意的情况下，会把远程dev分支上的东西合并到远程master分支上。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"vue-resource的使用","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/vue-resource/","text":"vue-resource的使用 Vue 要实现异步加载需要使用到 vue-resource 库。 Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。 vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 常见的请求：get post jsonp​ get请求 this.$http.get(url).then( function(res){}, function(err){} ) ​ post请求 this.$http.post( url, {}, { emulateJSON: true }).then( function(res){}, function(err){} ) ​ jsonp请求 this.$http.jsonp(url).then( function(res){}, function(err){} ) 注：post 发送数据到后端，需要第三个参数 {emulateJSON:true} 。vue-resource共提供七种请求方法 参数说明： ​ 处理响应的方法：","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"vue指令学习","date":"2020-01-05T11:40:54.022Z","path":"2020/01/05/vue指令/","text":"框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlv-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 Vue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 注意： v-model 只能运用在 表单元素中 在Vue中使用样式使用class样式 数组 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt; 数组中使用三元表达式 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 数组中嵌套对象 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 直接使用对象 1&lt;h1 :class&#x3D;&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是H1&lt;&#x2F;h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style&#x3D;&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是的H1&lt;&#x2F;h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：123data: &#123; h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;h1StyleObj&quot;&gt;这是H1&lt;&#x2F;h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：1234data: &#123; h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;, h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是H1&lt;&#x2F;h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for&#x3D;&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for&#x3D;&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;&#x2F;div&gt; 迭代数字 12&lt;p v-for&#x3D;&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;&#x2F;p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-showv-if 的特点：每次都会重新删除或创建元素 v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 v-if 有较高的切换性能消耗v-show 有较高的初始渲染消耗 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]}]