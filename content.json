[{"title":"vue-resource的使用","date":"2019-12-17T12:42:29.657Z","path":"2019/12/17/vue-resource/","text":"vue-resource的使用 Vue 要实现异步加载需要使用到 vue-resource 库。 Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。 vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 常见的请求：get post jsonp​ get请求 this.$http.get(url).then( function(res){}, function(err){} ) ​ post请求 this.$http.post( url, {}, { emulateJSON: true }).then( function(res){}, function(err){} ) ​ jsonp请求 this.$http.jsonp(url).then( function(res){}, function(err){} ) 注：post 发送数据到后端，需要第三个参数 {emulateJSON:true} 。vue-resource共提供七种请求方法 参数说明： ​ 处理响应的方法：","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"VUE实例的生命周期","date":"2019-12-16T11:22:26.274Z","path":"2019/12/16/vue生命周期/","text":"VUE实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"配置Git","date":"2019-12-15T11:34:00.459Z","path":"2019/12/15/配置Git/","text":"为了设置Git中的配置值，需要使用config命令。 告知Git你的身份这要根据用户名和电子邮件地址来确定，Git是一个源管理系统，它期望知道是谁在进行这些变更，以方便记录。 git config–global user.name git config–global user.email 实际上Git可以接受任何邮件地址，在设置时并不会对其进行验证，但是Git的一些高级功能可能会使用这个邮件地址，因此保证其正确性还是很有必要的。 配置范围 system 在系统级别配置意味着会被应用于指定机器上所有仓库。用config命令指定–system选项。 git config–system global 全局配置值适用于特定用户的所有仓库，这是用户适用最常见的级别。 git config–global local 该设置只用于一个仓库的上下文。 git config–local 设置的层次结构首先会在本地仓库配置中查找，然后查找全局配置，最后查找系统配置。如果找到一个值，那么就是用这个值。 查看配置值 git config 撤销配置值 git config –unset 列出配置值 git config –list 包含但不限于本地，全局，系统，如果同时设置将会一起显示，为了避免混淆，可以指定范围。 git config –global –list 一次性配置 git -c = 类似于键值对的形式 ​","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"移动内容的核心Git命令","date":"2019-12-13T12:31:28.949Z","path":"2019/12/13/git核心命令/","text":"从 到 命令 注解 工作目录 暂存区域 add 暂存本地变更 暂存区域 本地仓库 commit 仅提交暂存区域内容 本地仓库 远程仓库 push 在推送时同步内容 本地仓库 工作目录 checkout 切换当前分支 远程仓库 本地环境 clone 创建本地仓库和工作目录 远程仓库 本地仓库 fetch 更新远程分支的引用 远程仓库 本地仓库和工作目录 pull 抓取合并到本地分支和工作目录","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"Git升级模型","date":"2019-12-13T09:09:53.859Z","path":"2019/12/13/git/","text":"工作目录本地系统上的任何目录或目录树都可以成为Git仓库的工作目录。工作目录可以拥有形成一个整体工作区的任意数量的子目录。在将Git连接到本地目录树时，会创建一个仓库框架，也就是本地仓库（默认情况下本地仓库为.git） 可以通过–git-dir或者一个环境变量$GIT_DIR来重写git的默认位置。 暂存区域一个在变更被提交到本地仓库之前暂存变更的地方，保存已经从工作目录升级了的任意内容的集合。 两种使用场景： 1.准备场景 用户在工作区中完成变更，将文件移动到暂存区中，支持任意力度，甚至可以一个一个文件升级。 2.修复场景 拉取仓库中最后一次提交，更新其内容，推送会前一次提交的位置。 3.处理合并冲突 将无法解决的冲突放入工作目录中，暂存那些被干净合并的文件，待冲突解决后，暂存区包含一组完整的解决冲突后的文件，提交到本地仓库。 可以绕过暂存区吗？ 仅适用于Git已经在追踪的文件，这意味着文件首次被添加到Git时，必须经历暂存阶段。 本地仓库本地环境上Git级别的最后一个部分，通过两种方式来创建： 1.远程仓库的一份克隆 2.告知Git在本地初始化一个新环境 它是当前用户独占使用的一个源仓库，用户在对内容感到满意之前，都可以进行修改，之后可以将内容发送到远程仓库。如果工作目录被意外清除并且未同步到远程，那么内容将会丢失。如果其他人持续更新特定的远程仓库，那么从本地仓库将内容同步到远程仓库之间时间间隔越长，出现合并问题的概率越高。 远程仓库多个Git用户从各自本地仓库向上同步变更的地方。 远程仓库是唯一的，对于多个项目而言，可以有许多远程仓库，但不会再服务器生成或使用远程仓库的多个副本 可以根据需要将远程仓库多次克隆到不同的本地仓库","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"图解MVVM与MVC","date":"2019-12-11T13:29:58.626Z","path":"2019/12/11/图解MVVM与MVC/","text":"","comments":true,"tags":[{"name":"MVVM与MVC","slug":"MVVM与MVC","permalink":"https://www.github.com/qyg2019/tags/MVVM%E4%B8%8EMVC/"}]},{"title":"Vue指令学习","date":"2019-12-11T11:34:58.773Z","path":"2019/12/11/day1/","text":"框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlv-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 Vue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 注意： v-model 只能运用在 表单元素中 在Vue中使用样式使用class样式 数组 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt; 数组中使用三元表达式 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 数组中嵌套对象 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 直接使用对象 1&lt;h1 :class&#x3D;&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是H1&lt;&#x2F;h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style&#x3D;&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是的H1&lt;&#x2F;h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：1data: &#123;2 h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;3&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;h1StyleObj&quot;&gt;这是H1&lt;&#x2F;h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：1data: &#123;2 h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;,3 h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;4&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是H1&lt;&#x2F;h1&gt; Vue指令之v-for和key属性 迭代数组 1&lt;ul&gt;2 &lt;li v-for&#x3D;&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;3&lt;&#x2F;ul&gt; 迭代对象中的属性 12&lt;!-- 循环遍历对象身上的属性 --&gt;34 &lt;div v-for&#x3D;&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;&#x2F;div&gt; 迭代数字 12&lt;p v-for&#x3D;&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;&#x2F;p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-showv-if 的特点：每次都会重新删除或创建元素 v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 v-if 有较高的切换性能消耗v-show 有较高的初始渲染消耗 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"分布式版本控制系统Git常用命令浅谈","date":"2019-11-30T12:10:21.813Z","path":"2019/11/30/1/","text":"什么是Git Git下载地址Git是目前世界上最先进的分布式版本控制系统,具有备份， 记录操作时间线，多端共享代码（代替各种云盘的功能），‘自动’合并的功能。Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容基本是完全一样的。 Git原理及基本操作 本地仓库分为工作区、缓冲区以及仓库,每个仓库可以简单理解成一个目录，这个目录里面的所有文件都通过Git来实现版本管理，Git都能跟踪并记录在该目录中发生的所有更新。 安装好Git后，新建一个文件夹，单击右键gitbush,输入以下命令初始化一个本地仓库： 可以看到出现了一个文件夹： 接下来就可以在这个文件夹中进行开发了。 一顿苦逼的开发之后…… 使用add命令将指定文件或全部文件推入缓冲区​ ​ 使用commit命令推入本地仓库​ 至此一个版本开发完毕，当然git还提供更多命令来供用户操作，一起来了解下吧！ git status： 查看仓库当前的状态 ​ git diff +文件名：查看文件具体修改了哪里 ​ git log：查看最近到最远提交到仓库的文件信息(一串数字为特有的时间序列id 可以根据它进行版本前后回滚) git reset –hard HEAD^：回退到上一次 commit的时候 git reset –hard bdeacd: 版本前进 只能根据 id进行前进（id只写出前六位就好了） git reflog：查看每次操作仓库内的信息（commit）这样的话当黑窗口没了的时候，也可以查询具体操作信息， 进行版本回退或者前进! git checkout – read.txt: 工作区恢复到最近一次的commit或者add git rm +文件名: 删除某一个文件 需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。 git branch dev: 创建dev分支 git checkout dev： 切换到dev分支上开发 git branch：查看所有分支 git branch -d dev：删除分支 （-D 强制删除） git merge dev: 合并分支 在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作：1. 首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）2.可以通过git clone远程仓库（git clone git@github.com:HustCst/duyiApp.git）或者通过git remote add origin git@github.com:HustCst/duyiApp.git，是本地仓库和远程仓库相关联，git pull origin master，本地才有master分支！3.之后再本地master分支上的代码上传到 远程仓库上的master分支 第一次上传使用 git push –u origin master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过 git push origin master –f 强行让master分支上的本地文件覆盖远程master分支上的文件）ps:切记不要在本地master分支上开发，在其他分支如dev上开发后，合并到master上直接上传到 远程的 非master分支如dev分支，通过 git push origin master:dev; 之后项目参与者可以 new pull request 进行代码比对和阅读，项目管理人员在同意的情况下，会把远程dev分支上的东西合并到远程master分支上。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]}]