[{"title":"图解MVVM与MVC","date":"2019-12-11T13:29:58.626Z","path":"2019/12/11/图解MVVM与MVC/","text":"","comments":true,"tags":[{"name":"MVVM与MVC","slug":"MVVM与MVC","permalink":"https://www.github.com/qyg2019/tags/MVVM%E4%B8%8EMVC/"}]},{"title":"Vue指令学习","date":"2019-12-11T11:34:58.773Z","path":"2019/12/11/day1/","text":"框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlv-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 Vue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 注意： v-model 只能运用在 表单元素中 在Vue中使用样式使用class样式 数组 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt; 数组中使用三元表达式 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 数组中嵌套对象 1&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是H1&lt;&#x2F;h1&gt; 直接使用对象 1&lt;h1 :class&#x3D;&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是H1&lt;&#x2F;h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style&#x3D;&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是的H1&lt;&#x2F;h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式：1data: &#123;2 h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;3&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;h1StyleObj&quot;&gt;这是H1&lt;&#x2F;h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式：1data: &#123;2 h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;,3 h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;4&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中：1&lt;h1 :style&#x3D;&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是H1&lt;&#x2F;h1&gt; Vue指令之v-for和key属性 迭代数组 1&lt;ul&gt;2 &lt;li v-for&#x3D;&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;3&lt;&#x2F;ul&gt; 迭代对象中的属性 12&lt;!-- 循环遍历对象身上的属性 --&gt;34 &lt;div v-for&#x3D;&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;&#x2F;div&gt; 迭代数字 12&lt;p v-for&#x3D;&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;&#x2F;p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-showv-if 的特点：每次都会重新删除或创建元素 v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 v-if 有较高的切换性能消耗v-show 有较高的初始渲染消耗 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。","comments":true,"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.github.com/qyg2019/tags/Vue/"}]},{"title":"分布式版本控制系统Git常用命令浅谈","date":"2019-11-30T12:10:21.813Z","path":"2019/11/30/1/","text":"什么是Git Git下载地址Git是目前世界上最先进的分布式版本控制系统,具有备份， 记录操作时间线，多端共享代码（代替各种云盘的功能），‘自动’合并的功能。Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容基本是完全一样的。 Git原理及基本操作 本地仓库分为工作区、缓冲区以及仓库,每个仓库可以简单理解成一个目录，这个目录里面的所有文件都通过Git来实现版本管理，Git都能跟踪并记录在该目录中发生的所有更新。 安装好Git后，新建一个文件夹，单击右键gitbush,输入以下命令初始化一个本地仓库： 可以看到出现了一个文件夹： 接下来就可以在这个文件夹中进行开发了。 一顿苦逼的开发之后…… 使用add命令将指定文件或全部文件推入缓冲区​ ​ 使用commit命令推入本地仓库​ 至此一个版本开发完毕，当然git还提供更多命令来供用户操作，一起来了解下吧！ git status： 查看仓库当前的状态 ​ git diff +文件名：查看文件具体修改了哪里 ​ git log：查看最近到最远提交到仓库的文件信息(一串数字为特有的时间序列id 可以根据它进行版本前后回滚) git reset –hard HEAD^：回退到上一次 commit的时候 git reset –hard bdeacd: 版本前进 只能根据 id进行前进（id只写出前六位就好了） git reflog：查看每次操作仓库内的信息（commit）这样的话当黑窗口没了的时候，也可以查询具体操作信息， 进行版本回退或者前进! git checkout – read.txt: 工作区恢复到最近一次的commit或者add git rm +文件名: 删除某一个文件 需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。 git branch dev: 创建dev分支 git checkout dev： 切换到dev分支上开发 git branch：查看所有分支 git branch -d dev：删除分支 （-D 强制删除） git merge dev: 合并分支 在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作：1. 首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）2.可以通过git clone远程仓库（git clone git@github.com:HustCst/duyiApp.git）或者通过git remote add origin git@github.com:HustCst/duyiApp.git，是本地仓库和远程仓库相关联，git pull origin master，本地才有master分支！3.之后再本地master分支上的代码上传到 远程仓库上的master分支 第一次上传使用 git push –u origin master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过 git push origin master –f 强行让master分支上的本地文件覆盖远程master分支上的文件）ps:切记不要在本地master分支上开发，在其他分支如dev上开发后，合并到master上直接上传到 远程的 非master分支如dev分支，通过 git push origin master:dev; 之后项目参与者可以 new pull request 进行代码比对和阅读，项目管理人员在同意的情况下，会把远程dev分支上的东西合并到远程master分支上。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"https://www.github.com/qyg2019/tags/Git/"}]},{"title":"Hello World","date":"2019-11-29T08:58:12.644Z","path":"2019/11/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]