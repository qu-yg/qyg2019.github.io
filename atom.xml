<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yg.qu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.github.com/qyg2019/"/>
  <updated>2020-02-15T06:20:15.178Z</updated>
  <id>https://www.github.com/qyg2019/</id>
  
  <author>
    <name>屈永国</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用正则（传智播客总结）</title>
    <link href="https://www.github.com/qyg2019/2020/02/15/ES6-5/"/>
    <id>https://www.github.com/qyg2019/2020/02/15/ES6-5/</id>
    <published>2020-02-15T06:19:49.029Z</published>
    <updated>2020-02-15T06:20:15.178Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h5><p>1 数字：^[0-9]<em>$<br>2 n位的数字：^\d{n}$<br>3 至少n位的数字：^\d{n,}$<br>4 m-n位的数字：^\d{m,n}$<br>5 零和非零开头的数字：^(0|[1-9][0-9]</em>)$<br>6 非零开头的最多带两位小数的数字：^([1-9][0-9]<em>)+(.[0-9]{1,2})?$<br>7 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$<br>8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$<br>9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$<br>10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$<br>11 非零的正整数：^[1-9]\d</em>$ 或 ^([1-9][0-9]<em>){1,3}$ 或 ^+?[1-9][0-9]</em>$<br>12 非零的负整数：^-[1-9][]0-9”<em>$ 或 ^-[1-9]\d</em>$<br>13 非负整数：^\d+$ 或 ^[1-9]\d<em>|0$<br>14 非正整数：^-[1-9]\d</em>|0$ 或 ^((-\d+)|(0+))$<br>15 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0$<br>16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>))|0?.0+|0$<br>17 正浮点数：^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]*.[0-9]+)|([0-9]</em>[1-9][0-9]<em>))$<br>18 负浮点数：^-([1-9]\d*.\d</em>|0.\d<em>[1-9]\d</em>)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]*.[0-9]+)|([0-9]</em>[1-9][0-9]<em>)))$<br>19 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0)$</p><h4 id="二、校验字符的表达式"><a href="#二、校验字符的表达式" class="headerlink" title="二、校验字符的表达式"></a>二、校验字符的表达式</h4><p>1 汉字：^[\u4e00-\u9fa5]{0,}$<br>2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$<br>3 长度为3-20的所有字符：^.{3,20}$<br>4 由26个英文字母组成的字符串：^[A-Za-z]+$<br>5 由26个大写英文字母组成的字符串：^[A-Z]+$<br>6 由26个小写英文字母组成的字符串：^[a-z]+$<br>7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$<br>8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$<br>9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$<br>10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</p><h4 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h4><p>1 Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em>$<br>2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?<br>3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]<em>)?$<br>4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$<br>5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$<br>6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}<br>7 身份证号：<br>15或18位身份证：^\d{15}|\d{18}$<br>15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$<br>18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$<br>8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$<br>9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$<br>11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.</em>[a-z])(?=.<em>[A-Z]).{8,10}$<br>12 日期格式：^\d{4}-\d{1,2}-\d{1,2}<br>13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$<br>14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$<br>15 钱的输入格式：<br>16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]</em>$<br>17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]<em>)$<br>18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]</em>)$<br>19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$<br>20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$<br>21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$<br>22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})<em>(.[0-9]{1,2})?$<br>23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})</em>)(.[0-9]{1,2})?$<br>24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里<br>25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$<br>26 中文字符的正则表达式：[\u4e00-\u9fa5]<br>27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br>28 空白行的正则表达式：\n\s<em>\r (可以用来删除空白行)<br>29 HTML标记的正则表达式：&lt;(\S</em>?)[^&gt;]<em>&gt;.</em>?|&lt;.<em>? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)<br>30 首尾空白字符的正则表达式：^\s</em>|\s<em>$或(^\s</em>)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br>31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)<br>32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)<br>33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;一、校验数字的表达式&quot;&gt;&lt;a href=&quot;#一、校验数字的表达式&quot; class=&quot;headerlink&quot; title=&quot;一、校验数字的表达式&quot;&gt;&lt;/a&gt;一、校验数字的表达式&lt;/h5&gt;&lt;p&gt;1 数字：^[0-9]&lt;em&gt;$&lt;br&gt;2 n位的数字：^\d{n}$&lt;br
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令(七)</title>
    <link href="https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A47/"/>
    <id>https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A47/</id>
    <published>2020-02-14T13:23:28.747Z</published>
    <updated>2020-02-14T13:28:02.368Z</updated>
    
    <content type="html"><![CDATA[<h5 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo  apt  install  软件包</span><br></pre></td></tr></table></figure><h5 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo  apt  remove  软件名</span><br></pre></td></tr></table></figure><h5 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo  apt  upgrade</span><br></pre></td></tr></table></figure><h5 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h5><p>如果希望在 ubuntu 中安装软件,  <strong>更加快速 ,</strong> 可以通过设置<strong>镜像源,</strong> 选择一个访问网速更快的服务器淘宝镜像,阿里镜像,清华镜等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;安装软件&quot;&gt;&lt;a href=&quot;#安装软件&quot; class=&quot;headerlink&quot; title=&quot;安装软件&quot;&gt;&lt;/a&gt;安装软件&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令(六)</title>
    <link href="https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A46/"/>
    <id>https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A46/</id>
    <published>2020-02-14T13:17:29.789Z</published>
    <updated>2020-02-14T13:17:01.636Z</updated>
    
    <content type="html"><![CDATA[<h5 id="打包-解包"><a href="#打包-解包" class="headerlink" title="打包 / 解包"></a>打包 / 解包</h5><pre><code>Linux  常用 tar.gz</code></pre><p>tar  是 Linux 中最常用的 备份工具.  此命令可以 把一系列文件 打包到一个大文件中,  也可以把一个 打包的大文件恢复成一系列文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar  -cvf  打包文件.tar  被打包的文件 &#x2F; 路径     &#x2F;&#x2F;打包文件</span><br><span class="line">tar  -xvf  打包文件.tar    &#x2F;&#x2F;解包文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>x</th><th>解开档案文件</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件,创建打包文件</td></tr><tr><td>v</td><td>列出归档解档的详细过程,显示进度</td></tr><tr><td>f</td><td>指定档案文件名称, f 后面一定是 .tar 文件, 所以必须放选项最后</td></tr></tbody></table><h5 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩 / 解压缩"></a>压缩 / 解压缩</h5><p>gzip</p><p>tar 与 gzip 命令结合可以使用实现文件 打包和压缩<br>tar 只负责打包文件, 但不压缩</p><p>用 gzip 压缩 tar 打包后的文件,  其扩展名一般用 xxx.tar.gz</p><p>在 Linux 中,  最常见的压缩文件格式就是 xxx.tar.gz<br>在 tar 命令中有一个选项 -z 可以调用 gzip , 从而可以方便的实现压缩和解压缩的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar  -zcvf  打包文件.tar  被打包的文件 &#x2F; 路径     &#x2F;&#x2F;打包文件</span><br><span class="line">tar  -zxvf  打包文件.tar                        &#x2F;&#x2F;解包文件</span><br><span class="line">tar  -zxvf  打包文件.tar.gz  -C 目标路径         &#x2F;&#x2F;解压到指定路径</span><br></pre></td></tr></table></figure><p>bzip2 (two)</p><p>tar 与 bzip2 命令结合可以实现文件 打包和压缩 (用法和 gzip 一样)  ps : 扩展名一般用 : xxx.tar.bz2<br>在 tar 命令中有一个选项 -j 可以调用 bzip2 , 从而可以方便的实现压缩和解压缩的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar  -jcvf  打包文件.tar  被打包的文件 &#x2F; 路径     &#x2F;&#x2F;打包文件</span><br><span class="line">tar  -jxvf  打包文件.tar                        &#x2F;&#x2F;解包文件</span><br><span class="line">tar  -jxvf  打包文件.tar.gz  -C 目标路径         &#x2F;&#x2F;解压到指定路径</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;打包-解包&quot;&gt;&lt;a href=&quot;#打包-解包&quot; class=&quot;headerlink&quot; title=&quot;打包 / 解包&quot;&gt;&lt;/a&gt;打包 / 解包&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Linux  常用 tar.gz&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tar  是 Linux 中
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令(五)</title>
    <link href="https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A45/"/>
    <id>https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A45/</id>
    <published>2020-02-14T13:05:27.177Z</published>
    <updated>2020-02-14T13:09:14.734Z</updated>
    
    <content type="html"><![CDATA[<p>日期和时间</p><p>磁盘信息</p><p>文件查找</p><p>软连接</p><h5 id="查看系统时间"><a href="#查看系统时间" class="headerlink" title="查看系统时间"></a>查看系统时间</h5><table><thead><tr><th>date</th><th>查看系统时间</th></tr></thead><tbody><tr><td>cal</td><td>查看日历</td></tr></tbody></table><h5 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h5><table><thead><tr><th>df  -h</th><th>查看磁盘剩余空间</th></tr></thead><tbody><tr><td>du - h</td><td>查看目录下文件大小</td></tr></tbody></table><h5 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h5><table><thead><tr><th>ps  aux</th><th>查看进程的详细状况</th></tr></thead><tbody><tr><td>top</td><td>动态显示运行中的进程并且排序,小写q退出</td></tr><tr><td>kill  [-9] 进程代号</td><td>终止指定代号的进程, -9表示强行终止</td></tr></tbody></table><table><thead><tr><th>a</th><th>显示终端上的所有进程,包括其他用户的进程</th></tr></thead><tbody><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><h5 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h5><table><thead><tr><th>find   [路径] -name “.txt”</th><th>查找指定路径下扩展名是 .txt 的文件,包括子目录</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h5 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h5><table><thead><tr><th>ln -s 被连接的源文件链接文件</th><th>建立文件的软连接, 用通俗的方式讲 <strong>类似于 Windows</strong> 下的<strong>快捷方式</strong></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在使用 ln 创建链接时, 如果没有 -s 选项,  会创建一个 硬链接 ,  而不是软连接<br>在 Linux 中, 文件名 和 文件的数据 是分开储存的</p><p>在 Linux 中,  只有文件的 硬链接数 ==0 才会被删除, 就是说存在硬链接,即使删除了文件名,文件还在<br>使用 ls -l 可以查看一个文件的硬链接的数量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日期和时间&lt;/p&gt;
&lt;p&gt;磁盘信息&lt;/p&gt;
&lt;p&gt;文件查找&lt;/p&gt;
&lt;p&gt;软连接&lt;/p&gt;
&lt;h5 id=&quot;查看系统时间&quot;&gt;&lt;a href=&quot;#查看系统时间&quot; class=&quot;headerlink&quot; title=&quot;查看系统时间&quot;&gt;&lt;/a&gt;查看系统时间&lt;/h5&gt;&lt;table&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令(四)</title>
    <link href="https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A44/"/>
    <id>https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A44/</id>
    <published>2020-02-14T12:53:42.195Z</published>
    <updated>2020-02-14T12:53:09.154Z</updated>
    
    <content type="html"><![CDATA[<h5 id="用户-和-权限-的概念"><a href="#用户-和-权限-的概念" class="headerlink" title="用户 和 权限 的概念"></a>用户 和 权限 的概念</h5><p>用户 是Linux 系统工作中中的一环, 用户管理包括 用户 和 组 管理<br>在 Linux 系统中,  不论是由本级或是远程登录系统,  每个系统都必须有一个账号, 并且对于不同的系统资源有不同的使用权限<br>在 Linux 中, 可以指定 每一个用户 针对 不同的文件或者目录 的不同权限<br>对 文件 / 目录 的权限包括:</p><table><thead><tr><th>权限</th><th>缩写</th><th>代号</th></tr></thead><tbody><tr><td>读</td><td>r</td><td>4</td></tr><tr><td>写</td><td>w</td><td>2</td></tr><tr><td>执行</td><td>x</td><td>1</td></tr></tbody></table><h5 id="组"><a href="#组" class="headerlink" title="组"></a>组</h5><p>在实际应用中, 可以预先对 组 设置好权限, 然后 将不同的用户添加到对应的组中, 从而不用一次为每一个用户设置</p><h5 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h5><p>chmod 简单使用</p><p>chmod 可以修改 用户 / 组 对 文件 / 目录 的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +&#x2F;-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><p> 超级用户</p><p>Linux  系统中的 root 账号通常 用于系统的维护和管理 ,  对操作系统的所有资源 具有所有访问权限<br>在大多数版本的 Linux 中 , 都不推荐 直接使用 root 账号登录系统<br>在 Linux 安装的过程中, 系统会自动创建一个用户账号,  而这个默认的用户就称为 “标准用户” </p><h5 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h5><p>su 是 substitute user 的缩写,  表示 使用另一个用户的身份<br>sudo 命令来以其他身份来执行命令,  预设的身份为 root<br>用户使用 sudo 时,必须先输入密码,  之后有5分钟的有效期限,  超过期限则必须重新输入密码</p><h5 id="组管理-终端命令"><a href="#组管理-终端命令" class="headerlink" title="组管理 终端命令"></a>组管理 终端命令</h5><p>创建组 / 删除组 的终端命令都需要通过 sudo 执行</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>groupadd</td><td>添加组</td></tr><tr><td>groupdel</td><td>删除组</td></tr><tr><td>chgrp</td><td>修改文件 / 目录的所属组</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp 组名  文件 &#x2F; 目录名修改文件 &#x2F; 目录的所属组</span><br></pre></td></tr></table></figure><p>组信息保存在 /etc/group 文件中</p><h5 id="创建用户-设置密码-删除用户"><a href="#创建用户-设置密码-删除用户" class="headerlink" title="创建用户 / 设置密码 / 删除用户"></a>创建用户 / 设置密码 / 删除用户</h5><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd -m -g     新建用户名</td><td>添加新用户     -m 自动建立用户家目录</td></tr><tr><td>passwd  用户名</td><td>设置用户密码    如果是普通用户, 直接用 passwd 可以修改自己的账户密码</td></tr><tr><td>userdel  -r  用户名</td><td>删除用户    -r 选项会自动删除用户家目录</td></tr></tbody></table><p>创建用户时, 如果忘记添加 -m 选项指定新用户的家目录 — 最简单的方法就是删除用户,  重新创建<br>创建用户时, 默认会创建一个和用户名同名的组名<br>用户信息保存在 /etc/passwd 文件中</p><h5 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h5><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>id   [用户名]</td><td>查看用户 UID 和 GID 信息</td></tr><tr><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table><p>passwd 文件</p><p>/etc/passwd  文件存放的是用户的信息, 由 6 个分号组成的 7 个信息,  分别是</p><p>用户名<br>密码 (x,  表示加密的密码)<br>UID (用户标识)<br>GID (组标识)<br>用户全名 或 本地账号<br>家目录<br>登录使用的 Shell , 就是登录之后,  使用的终端命令,  ubuntu 默认是 dash</p><p>usermod </p><p>usermod 可以用来设置 用户 的 主组 / 附加组 和 登录 Shell,  命令格式如下 :<br>主组 : 通常在新建用户时指定, 在etc / passwd 的第 4 列 GID 对应的组<br>附加组 : 在 etc / group 中最后一列表示该组的用户列表, 用于指定 用户的附加权限</p><p>设置了用户的附加组之后, 需要重新登录才能生效</p><h5 id="修改用户主组"><a href="#修改用户主组" class="headerlink" title="修改用户主组"></a>修改用户主组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod  -g  组  用户名</span><br></pre></td></tr></table></figure><h5 id="修改用户附加组"><a href="#修改用户附加组" class="headerlink" title="修改用户附加组"></a>修改用户附加组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod  -G  组  用户名</span><br></pre></td></tr></table></figure><h5 id="修改用户登录shell"><a href="#修改用户登录shell" class="headerlink" title="修改用户登录shell"></a>修改用户登录shell</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod  -s  &#x2F;bin&#x2F;bash  用户名</span><br></pre></td></tr></table></figure><h5 id="which"><a href="#which" class="headerlink" title="which"></a><strong>which</strong></h5><p>查看执行命令所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which ls      &#x2F;&#x2F;      &#x2F;bin&#x2F;ls</span><br><span class="line"></span><br><span class="line">which useradd    &#x2F;&#x2F;    &#x2F;usr&#x2F;sbin&#x2F;useradd</span><br></pre></td></tr></table></figure><p>bin 和 sbin</p><p>在 Linux 中, 绝大多数可执行文件都是保存在 /bin , /sbin , /usr/bin , /usr/sbin<br>/bin (binary) 是二进制执行文件目录, 主要用于具体应用<br>/sbin (system binary) 是系统管理员专用的二进制代码存放目录,  主要用于系统管理<br>/usr/bin (user commands for applications) 后期安装的一些软件<br>/usr/sbin (super user commands for applications) 超级用户的一些管理程序</p><h5 id="切换用户su"><a href="#切换用户su" class="headerlink" title="切换用户su"></a>切换用户su</h5><table><thead><tr><th>su -用户名</th><th>切换用户</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>su 不接用户名,  可以切换到 root</p><h5 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h5><table><thead><tr><th>chown</th><th>修改拥有着</th></tr></thead><tbody><tr><td>chgrp</td><td>修改组</td></tr><tr><td>chmod</td><td>修改权限</td></tr></tbody></table><p>chmod的数字表示</p><table><thead><tr><th>拥有着</th><th>组用户</th><th>其他用户</th></tr></thead><tbody><tr><td>rwx</td><td>rwx</td><td>rwx</td></tr><tr><td>421</td><td>421</td><td>421</td></tr></tbody></table><table><thead><tr><th>000</th><th>0</th><th>—</th></tr></thead><tbody><tr><td>001</td><td>1</td><td>–x</td></tr><tr><td>020</td><td>2</td><td>-w-</td></tr><tr><td>021</td><td>3</td><td>-wx</td></tr><tr><td>400</td><td>4</td><td>r–</td></tr><tr><td>401</td><td>5</td><td>r-x</td></tr><tr><td>420</td><td>6</td><td>rw-</td></tr><tr><td>421</td><td>7</td><td>rwx</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod  741 文件名 | 目录名   &#x2F;&#x2F;拥有着rwx权限  组用户r--权限   其他用户x权限</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;用户-和-权限-的概念&quot;&gt;&lt;a href=&quot;#用户-和-权限-的概念&quot; class=&quot;headerlink&quot; title=&quot;用户 和 权限 的概念&quot;&gt;&lt;/a&gt;用户 和 权限 的概念&lt;/h5&gt;&lt;p&gt;用户 是Linux 系统工作中中的一环, 用户管理包括 用户 和 组
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令(三)</title>
    <link href="https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A43/"/>
    <id>https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A43/</id>
    <published>2020-02-14T08:40:05.059Z</published>
    <updated>2020-02-14T08:39:45.442Z</updated>
    
    <content type="html"><![CDATA[<h5 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h5><p>可以 安全 关闭 或者 重新启动系统</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown  选项  时间</td><td>关机或重新启动</td></tr></tbody></table><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-r</td><td>重新启动</td></tr></tbody></table><ul><li>不指定选项和参数, 默认表示 <strong>1 分钟</strong> 之后 <strong>关闭电脑</strong></li><li>远程维护服务器时, 最好不要关闭系统, 而应该重新启动系统</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ shutdown -r now   &#x2F;&#x2F;现在重启</span><br><span class="line"></span><br><span class="line">$ shutdown  now    &#x2F;&#x2F;现在关机</span><br><span class="line"></span><br><span class="line">$ shutdown 20:00  &#x2F;&#x2F;20：00关机</span><br><span class="line"></span><br><span class="line">$ shutdown +10  &#x2F;&#x2F;10分钟后关机</span><br><span class="line"></span><br><span class="line">$ shutdown -c  &#x2F;&#x2F;取消</span><br></pre></td></tr></table></figure><h5 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h5><p>可以查看  /  配置计算机当前的网卡配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  ifconfig  |  grep  inet</span><br></pre></td></tr></table></figure><h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p> 一般用于检测当前计算机到目标计算机之间的网络  是否通畅,  数值越大,  速度越慢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  ping wwww.baidu.com           &#x2F;&#x2F;或者IP地址</span><br></pre></td></tr></table></figure><h5 id="远程登录和远程复制文件"><a href="#远程登录和远程复制文件" class="headerlink" title="远程登录和远程复制文件"></a>远程登录和远程复制文件</h5><table><thead><tr><th>ssh   用户名@ip地址</th><th>登录</th></tr></thead><tbody><tr><td>scp  源    目的</td><td>远程复制文件</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-p port] user@remote</span><br></pre></td></tr></table></figure><table><thead><tr><th>ssh服务器</th><th>22</th></tr></thead><tbody><tr><td>web服务器</td><td>80</td></tr><tr><td>https</td><td>443</td></tr><tr><td>ftp</td><td>21</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit     &#x2F;&#x2F;退出登录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -P port 123.txt user@remote:Desktop&#x2F;123.txt</span><br><span class="line"></span><br><span class="line">#  把远程 家目录下的 Desktop&#x2F;123.txt 文件  复制到 本地当前目录下的 123.txt</span><br></pre></td></tr></table></figure><ul><li>scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用</li><li>如果在 Windows 系统中,  可以安装 PuTTY, 使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输</li></ul><h5 id="SSH-高级"><a href="#SSH-高级" class="headerlink" title="SSH 高级"></a>SSH 高级</h5><p>免密码登录<br>配置别名<br>   有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下</p><p>配置公钥<br>       执行 ssh-keygen 即可生成 SSH 钥匙,  一路回车即可</p><p>上传公钥到服务器<br>       执行 ssh-copy-id -p port user@remote, 可以让远程服务器记住我们的公钥 </p><p> 带pub的是公钥(public)</p><p>a. 客户端执行 ssh-copy-id -p port user@remote, 可以让远程服务器记住我们的公钥 ,客户端=&gt;私钥,服务端=&gt;公钥</p><p>b. 客户端发送数据给服务端时通过 私钥加密,  服务端通过 公钥解密 发送过来的数据.</p><p>c. 服务端发送数据给客户端时通过 公钥解密 ,  客户端通过 私钥解密 发送过来的数据.</p><p>2)  配置别名 </p><p>在 ~/.ssh/config 里面追加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Host mac &#x2F;&#x2F;指定别名</span><br><span class="line"></span><br><span class="line">    HostName  ip地址</span><br><span class="line"></span><br><span class="line">    User  用户名</span><br><span class="line"></span><br><span class="line">    port 22</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;shutdown命令&quot;&gt;&lt;a href=&quot;#shutdown命令&quot; class=&quot;headerlink&quot; title=&quot;shutdown命令&quot;&gt;&lt;/a&gt;shutdown命令&lt;/h5&gt;&lt;p&gt;可以 安全 关闭 或者 重新启动系统&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令(二)</title>
    <link href="https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A42/"/>
    <id>https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A42/</id>
    <published>2020-02-14T07:54:28.185Z</published>
    <updated>2020-02-14T07:59:48.442Z</updated>
    
    <content type="html"><![CDATA[<h5 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h5><p>敲出 命令/目录/文件  的前几个字母 ,  按下 Tab 键，快速补全<br>按  上 / 下  光标,可以再曾经使用过的命令之间来回切换.<br>退出选择, 不执行当前命令,按    ctrl  +  c</p><h5 id="ls命令说明"><a href="#ls命令说明" class="headerlink" title="ls命令说明"></a>ls命令说明</h5><p>ls是list 的简写, 列出文件夹目录,  ps: 用得最多的命令</p><p>Linux下文件和目录的特点：</p><p>Linux 文件 或者 目录 名称最长可以有 256 个字符<br>以 . (点)开头的文件为隐藏文件,  需要用 -a 参数才能显示<br> .(点)  代表当前目录<br> .. (两个点)  代表上一级目录</p><h5 id="ls常用选项"><a href="#ls常用选项" class="headerlink" title="ls常用选项"></a>ls常用选项</h5><table><thead><tr><th>-a</th><th>显示指定目录下所有子目录与文件,包括隐藏文件</th></tr></thead><tbody><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><h5 id="命令-cd"><a href="#命令-cd" class="headerlink" title="命令 cd"></a>命令 cd</h5><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主要目录(/home/用户目录)</td></tr><tr><td>cd ~</td><td>切换到当前用户的主要目录(/home/用户目录)</td></tr><tr><td>cd .</td><td>保持在当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>最近两个目录来回切</td></tr></tbody></table><p>相对路径  在输入路径时,  最前面不是 / 或者 - ,表示相对 当前目录 所在的目录位置<br>绝对路径  在输入路径时,  最前面是 / 或者 - ,表示从 根目录/家目录 开始的具体目录位置</p><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p>创建一个新的目录</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>递归创建目录</td></tr></tbody></table><p>创建 mkdir -p a/b/c   </p><h5 id="命令rm"><a href="#命令rm" class="headerlink" title="命令rm"></a>命令rm</h5><p>删除文件或目录</p><p> 使用rm删除不能恢复</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>强制删除, 忽略不存在的文件, 无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容, 删除文件夹 时必须加此参数</td></tr></tbody></table><h5 id="拷贝和移动文件"><a href="#拷贝和移动文件" class="headerlink" title="拷贝和移动文件"></a>拷贝和移动文件</h5><table><thead><tr><th>tree[目录名]</th><th>以树状图列出文件目录结构</th></tr></thead><tbody><tr><td>cp 源文件 目标文件</td><td>复制文件或目录</td></tr><tr><td>mv 源文件 目标文件</td><td>移动文件或者目录 / 文件或者目录重命名</td></tr></tbody></table><h5 id="cp选项"><a href="#cp选项" class="headerlink" title="cp选项"></a>cp选项</h5><table><thead><tr><th>-f</th><th>已经存在的目标文件直接覆盖,  不会提示</th></tr></thead><tbody><tr><td>-r</td><td>若给出的源文件是目录文件, 则 cp 将递归复制该目录下的所有子目录和文件,目标文件必须是一个目录名</td></tr><tr><td>-i</td><td>覆盖文件前提示</td></tr></tbody></table><h5 id="mv选项"><a href="#mv选项" class="headerlink" title="mv选项"></a>mv选项</h5><table><thead><tr><th>-i</th><th>覆盖文件前提示</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h5 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h5><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>cat</td><td>查看文件内容,创建文件,文件合并,追加文件内容等功能</td></tr><tr><td>more</td><td>分屏显示文件内容</td></tr><tr><td>grep</td><td>搜索文本文件内容</td></tr></tbody></table><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>cat 会一次显示所有的内容, 适合 查看内容较少 的文本文件</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>对非空输出行编号</td></tr><tr><td>-n</td><td>对输出的所有行编号</td></tr></tbody></table><h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>Linux 系统中 grep 命令是一种强大的文本搜索工具<br>grep 允许文本文件进行 模式查找, 所谓模式查找,  又被称为正则表达式,</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行(相当于求反)</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><p>常用的两种模式查找</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>^a</td><td>搜寻以a 开头的行</td></tr><tr><td>b$</td><td>搜寻以b 结束的行</td></tr></tbody></table><p>gedit 目录名/文件名 直接打开文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;实用技巧&quot;&gt;&lt;a href=&quot;#实用技巧&quot; class=&quot;headerlink&quot; title=&quot;实用技巧&quot;&gt;&lt;/a&gt;实用技巧&lt;/h5&gt;&lt;p&gt;敲出 命令/目录/文件  的前几个字母 ,  按下 Tab 键，快速补全&lt;br&gt;按  上 / 下  光标,可以再曾经使用过的
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令(一)</title>
    <link href="https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A41/"/>
    <id>https://www.github.com/qyg2019/2020/02/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A41/</id>
    <published>2020-02-14T06:57:40.743Z</published>
    <updated>2020-02-14T08:04:23.782Z</updated>
    
    <content type="html"><![CDATA[<ul><li>职场中程序员多数用到的是终端命令,而不是界面的一些东西</li><li>程序员必须掌握一些常用的终端命令</li><li>常用的命令只有 十几二十 多个</li></ul><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><table><thead><tr><th>1</th><th>ls</th><th>list</th><th>查看当前文件夹下的内容</th></tr></thead><tbody><tr><td>2</td><td>pwd</td><td>print work direction</td><td>查看当前所在文件夹</td></tr><tr><td>3</td><td>cd[目录名]</td><td>change direction</td><td>切换文件夹</td></tr><tr><td>4</td><td>touch[文件名]</td><td>touch</td><td>如果文件不存在，创建文件</td></tr><tr><td>5</td><td>mkdir[目录名]</td><td>make direction</td><td>创建目录，新建文件夹</td></tr><tr><td>6</td><td>rm[文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>7</td><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><table><thead><tr><th>ctrl  shift   =</th><th>放大终端窗口的字体显示</th></tr></thead><tbody><tr><td>ctrl    -</td><td>缩小终端窗口的字体显示</td></tr></tbody></table><h4 id="终端命令的格式"><a href="#终端命令的格式" class="headerlink" title="终端命令的格式"></a>终端命令的格式</h4><p>command  [-options]  parameter </p><p>(选择目录 : cd 目录名称)</p><p>(删除目录 : rm -r 目录名字)</p><p>command :  命令名    (ls  ,pwd   ,clear …..)<br>[-options] : 选项,可省略    [ ]代表可选<br>parameter :传给命令的参数   (文件夹名等…)</p><p>####查看帮助</p><p> –help    语法 :  command –help<br>  man     语法 : man command  </p><p>使用man时的操作键</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格</td><td>下一页内容</td></tr><tr><td>b</td><td>回滚一页</td></tr><tr><td>f</td><td>前进一页b</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>enter</td><td>滚动一行</td></tr></tbody></table><h4 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h4><table><thead><tr><th>删除操作</th><th>rm</th></tr></thead><tbody><tr><td>拷贝文件</td><td>cp</td></tr><tr><td>移动文件</td><td>mv</td></tr><tr><td>查看文件内容</td><td>cat        more</td></tr><tr><td>搜索</td><td>grep</td></tr><tr><td>重定向</td><td>&gt;</td></tr><tr><td>追加内容</td><td>&gt; &gt;</td></tr><tr><td>管道</td><td>|</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;职场中程序员多数用到的是终端命令,而不是界面的一些东西&lt;/li&gt;
&lt;li&gt;程序员必须掌握一些常用的终端命令&lt;/li&gt;
&lt;li&gt;常用的命令只有 十几二十 多个&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;基本命令&quot;&gt;&lt;a href=&quot;#基本命令&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.github.com/qyg2019/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>扩展对象的功能性</title>
    <link href="https://www.github.com/qyg2019/2020/02/08/ES6-4/"/>
    <id>https://www.github.com/qyg2019/2020/02/08/ES6-4/</id>
    <published>2020-02-08T12:32:39.486Z</published>
    <updated>2020-02-08T12:34:56.735Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>普通对象</strong>        具有javascript对象所有默认内部行为</li><li><strong>特异对象</strong>         具有某些与默认行为不符的内部行为</li><li><strong>标准对象</strong>         ES6中规范中定义的对象</li><li><strong>内建对象</strong>         脚本执行时存在于JavaScript执行环境中的对象</li></ul><h4 id="属性初始值，对象方法简写"><a href="#属性初始值，对象方法简写" class="headerlink" title="属性初始值，对象方法简写"></a>属性初始值，对象方法简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function creat()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        name,      &#x2F;&#x2F;相当于 name:name</span><br><span class="line">        age        &#x2F;&#x2F;相当于 age:age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> var person &#x3D; &#123;</span><br><span class="line">     sayName()&#123;</span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F;函数体</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h4><p>Object.is()   弥补全等运算符的不准确运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(+0 &#x3D;&#x3D; -0)    &#x2F;&#x2F;true</span><br><span class="line">console.log(+0 &#x3D;&#x3D;&#x3D; -0)   &#x2F;&#x2F;true</span><br><span class="line">console.log(Object.is(+0,-0) )   &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(NaN &#x3D;&#x3D; NaN)   &#x2F;&#x2F;false</span><br><span class="line">console.log(NaN &#x3D;&#x3D;&#x3D; NaN)  &#x2F;&#x2F;false</span><br><span class="line">console.log(Object.is(NaN,NaN))  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p> Object.assign()  接受任意数量的源对象，并按指定顺序将属性复制到接收对象中，排位靠后的同名属性会覆盖靠前的。</p><ul><li>不能将提供者的访问器属性复制到接收对象中</li></ul><h4 id="自有属性枚举顺序"><a href="#自有属性枚举顺序" class="headerlink" title="自有属性枚举顺序"></a>自有属性枚举顺序</h4><ol><li>所有数字键升序排序</li><li>所有字符串按照加入顺序排序</li><li>所有symbol键按照加入顺序排序</li></ol><h4 id="改变对象的原型"><a href="#改变对象的原型" class="headerlink" title="改变对象的原型"></a>改变对象的原型</h4><p>Object.getPrototypeof()   返回指定对象的原型</p><p>Object.setPrototypeof()   改变指定对象的原型    </p><h4 id="super关键字调用对象原型的方法"><a href="#super关键字调用对象原型的方法" class="headerlink" title="super关键字调用对象原型的方法"></a>super关键字调用对象原型的方法</h4><p>​                                                        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通对象&lt;/strong&gt;        具有javascript对象所有默认内部行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特异对象&lt;/strong&gt;         具有某些与默认行为不符的内部行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标准对象&lt;/
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="https://www.github.com/qyg2019/2020/02/08/ES6-3/"/>
    <id>https://www.github.com/qyg2019/2020/02/08/ES6-3/</id>
    <published>2020-02-08T11:40:59.196Z</published>
    <updated>2020-02-08T11:40:31.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ES6中默认参数值"><a href="#ES6中默认参数值" class="headerlink" title="ES6中默认参数值"></a>ES6中默认参数值</h4><p>es6简化了为形参提供默认参数值的过程，如果没有参数传入则为其提供一个初始值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout &#x3D; 2000,callback &#x3D; function()&#123;&#125;)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeRequest(&#39;&#x2F;foo&#39;)   &#x2F;&#x2F;使用timeout callback的默认值</span><br><span class="line">makeRequest(&#39;&#x2F;foo&#39;，500)   &#x2F;&#x2F;使用callback的默认值</span><br><span class="line">如果同时传入三个参数则不使用默认值，在已指定默认参数后可以继续声明无默认值参数，这种时候需要为其传入undefined才会使用其默认值。</span><br></pre></td></tr></table></figure><h4 id="默认参数值对arguments对象的影响"><a href="#默认参数值对arguments对象的影响" class="headerlink" title="默认参数值对arguments对象的影响"></a>默认参数值对arguments对象的影响</h4><ul><li><p>当使用默认参数值时arguments对象的行为与以往不同</p></li><li><p>arguments对象行为与ES5严格模式保持一致，默认参数值的存在使得arguments对象保持与命名参数分离,</p><p>改变first和second并不会影响arguments对象。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function args(first,second &#x3D; &#39;b&#39;)&#123;</span><br><span class="line">    console.log(arguments.length)</span><br><span class="line">    console.log(first &#x3D;&#x3D;&#x3D; arguments[0])</span><br><span class="line">    console.log(second &#x3D;&#x3D;&#x3D; arguments[1])</span><br><span class="line">    first &#x3D;&#39;c&#39;</span><br><span class="line">    second &#x3D; &#39;d&#39;</span><br><span class="line">    console.log(first &#x3D;&#x3D;&#x3D; arguments[0])</span><br><span class="line">    console.log(second &#x3D;&#x3D;&#x3D; arguments[1])</span><br><span class="line">&#125;</span><br><span class="line">args(&#39;a&#39;)</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h4 id="默认参数的临时死区"><a href="#默认参数的临时死区" class="headerlink" title="默认参数的临时死区"></a>默认参数的临时死区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(first&#x3D;second, second)&#123;</span><br><span class="line">    return first + second</span><br><span class="line">&#125;</span><br><span class="line">add(1,1)   &#x2F;&#x2F;2</span><br><span class="line">add(undefined,1)  &#x2F;&#x2F;抛出错误</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">let first &#x3D; second</span><br><span class="line">let second &#x3D; 1</span><br><span class="line">在second未初始化时访问会抛出错误</span><br></pre></td></tr></table></figure><h4 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h4><p>在函数命名参数前添加  <em>…</em>  就表明这是一个不定参数，该参数为一个数组，通过数组名即可一一访问里面的参数。 </p><ul><li>每个函数最多只能声明一个不定参数</li><li>一定要放在所有参数的末尾</li><li>不定参数不能用于对象字面量setter之中</li><li>无论 是否使用不定参数，arguments对象总是包含传入函数的所有参数</li></ul><h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p>将数组打散后作为独立的参数传入函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let values &#x3D; [25,70,50,100]</span><br><span class="line">console.log(Math.max(...values))   &#x2F;&#x2F;100</span><br></pre></td></tr></table></figure><h4 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h4><p>所有函数的<strong>name</strong>属性都有一个合适的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">   &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function doSomethingElse()&#123;</span><br><span class="line">   &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">console.log(doSomething.name)        &#x2F;&#x2F;doSomething</span><br><span class="line">console.log(doSomethingElse.name)    &#x2F;&#x2F;doSomethingElse</span><br></pre></td></tr></table></figure><ul><li>getter 和 setter函数中name属性有 <strong>get</strong> 和  <strong>set</strong>前缀</li><li>通过bind()函数创建的函数有<strong>bound</strong>前缀</li><li>通过Function创建的函数带有<strong>anonymous</strong>前缀</li><li>不能用name属性来获取对于函数的引用</li></ul><p>​                                                </p><hr><p>javascript函数有两个不同的内部方法： <strong>[[Call]]</strong> 和 <strong>[[Construct]]</strong> 。通过<strong>new</strong>关键字调用函数时执行的是 <strong>[[Construct]]</strong> 函数，负责创建实例对象，然后在执行函数体，将<strong>this</strong>绑定到实例上，如果不通过<strong>new</strong>关键字调用则执行 <strong>[[Call]]</strong>方法，具有 <strong>[[Construct]]</strong> 方法的函数称为构造函数。</p><hr><h4 id="判断函数被调用的方法"><a href="#判断函数被调用的方法" class="headerlink" title="判断函数被调用的方法"></a>判断函数被调用的方法</h4><p>ES5中用instanceof</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">if(this instanceof Person)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    throw new error(&#39;必须通过new调用&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person（&#39;nike&#39;）</span><br><span class="line">var person1 &#x3D;  Person（&#39;nike&#39;）   &#x2F;&#x2F;抛出错误</span><br></pre></td></tr></table></figure><ul><li>这个方法不可靠，Person.call(),   Person.apply()也可以将this绑定到Person的实例上</li></ul><p>ES6引入元属性<strong>new.target</strong>解决这个问题</p><ul><li>当调用<strong>[[Construct]]</strong> 方法时，new.target被赋值为<strong>new</strong>操作符的目标,通常是新创建对象实例</li><li>当调用 <strong>[[Call]]</strong>方法时，new.target被赋值为<strong>undefined</strong></li></ul><p>可以通过new.target__是否被定义__来安全地检测函数是否通过new关键字来调用。</p><hr><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul><li>没有this，super，arguments，new.target绑定，这些值有外围最近一层非箭头函数觉得</li><li>不能通过new关键字调用</li><li>没有原型</li><li>不可以改变this的绑定</li><li>不支持arguments对象</li><li>不支持重复的命名参数</li></ul><p>语法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let reflect &#x3D; value &#x3D;&gt; value   &#x2F;&#x2F; 只有一个参数时</span><br><span class="line">相当于</span><br><span class="line">let reflect &#x3D; function(value)&#123;</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let sum &#x3D; (num1,num2) &#x3D;&gt; num1 + num2  &#x2F;&#x2F;两个或两个以上参数时</span><br><span class="line">相当于</span><br><span class="line">let sum &#x3D; function(num1,num2)&#123;</span><br><span class="line">    return num1+num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果需要返回对象字面量，需将其包裹在&#123;&#125;里</span><br><span class="line">let getItem &#x3D; id &#x3D;&gt;(&#123;id:id,name:&quot;temp&quot;&#125;)</span><br></pre></td></tr></table></figure><h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>尾调用指的是函数作为另一个函数的最后一条语句调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">    </span><br><span class="line">    return doSomethingElse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尾调用不访问当前栈帧的变量，也就是说函数不是一个闭包</li><li>在函数内部，尾调用时最后一条语句</li><li>尾调用的结果作为函数值返回 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ES6中默认参数值&quot;&gt;&lt;a href=&quot;#ES6中默认参数值&quot; class=&quot;headerlink&quot; title=&quot;ES6中默认参数值&quot;&gt;&lt;/a&gt;ES6中默认参数值&lt;/h4&gt;&lt;p&gt;es6简化了为形参提供默认参数值的过程，如果没有参数传入则为其提供一个初始值。&lt;/p
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>字符串和正则表达式</title>
    <link href="https://www.github.com/qyg2019/2020/02/04/ES6-2/"/>
    <id>https://www.github.com/qyg2019/2020/02/04/ES6-2/</id>
    <published>2020-02-04T06:49:43.884Z</published>
    <updated>2020-02-04T06:48:39.108Z</updated>
    
    <content type="html"><![CDATA[<h5 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt()方法"></a>codePointAt()方法</h5><p>ES6新增完全支持UTF-16的方法，接受编码单元位置而非字符位置作为参数，返回对应位置的码位。</p><h5 id="String-fromCodePoint-方法"><a href="#String-fromCodePoint-方法" class="headerlink" title="String.fromCodePoint()方法"></a>String.fromCodePoint()方法</h5><p>根据指定码位生成一个字符。</p><h5 id="normalize-方法"><a href="#normalize-方法" class="headerlink" title="normalize()方法"></a>normalize()方法</h5><p>提供Unicode的标准化形式 。接受一个可选的字符串参数。</p><ul><li>NFC  默认选项</li><li>NFD </li><li>NFKC</li><li>NFKD</li></ul><p>在进行排序和比较操作前，将被操作字符串按照同一标准进行标准化。</p><h4 id="正则表达式u修饰符"><a href="#正则表达式u修饰符" class="headerlink" title="正则表达式u修饰符"></a>正则表达式u修饰符</h4><p>为一个正则表达式添加u修饰符，就从编码操作模式切换为字符模式，就不会视代理对为两个字符。</p><h4 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h4><p>返回当前正则表达式的修饰字符串</p><figure class="highlight plain"><figcaption><span>reg </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;ab&#x2F;g</span><br><span class="line">console.log(reg.flags)   &#x2F;&#x2F;g</span><br><span class="line">console.log(reg.source)  &#x2F;&#x2F;ab</span><br></pre></td></tr></table></figure><h4 id="其他字符串变更"><a href="#其他字符串变更" class="headerlink" title="其他字符串变更"></a>其他字符串变更</h4><ul><li>includes()</li></ul><p>​         在字符串中检测到指定文本返回true</p><ul><li>startswith()</li></ul><p>​         在字符串的起始部分检测到指定文本返回true</p><ul><li><p>endswith()</p><p>  在字符串的起始部分检测到指定文本返回true</p><p>以上的方法都接受两个参数，第二个参数是可选的，如果指定了第二个参数，includes()，startswith()会从这个位置开始匹配，endswith()会从字符串长度减去这个位置开始匹配。  </p></li><li><p>repeat()方法</p></li></ul><p>​         接受一个number类型的参数，表示该字符串重复的次数。</p><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><ul><li><p>多行字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let msg &#x3D; &#96;multiline</span><br><span class="line">string&#96;</span><br><span class="line">console.log(msg)   &#x2F;&#x2F;multiline</span><br><span class="line">                   &#x2F;&#x2F;string</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>字符串占位符<strong>${}</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name &#x3D; &quot;jobs&quot;</span><br><span class="line">let msg &#x3D;  &quot;hello,$&#123;name&#125;&quot;</span><br><span class="line">console.log(msg)    &#x2F;&#x2F; hello,jobs</span><br></pre></td></tr></table></figure><p>​</p></li></ul><p>​      可以把任何合法的javascript表达式嵌入到占位符中作为字符串的一部分输出到结果中</p><ul><li>标签模板</li></ul><p>​       它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;codePointAt-方法&quot;&gt;&lt;a href=&quot;#codePointAt-方法&quot; class=&quot;headerlink&quot; title=&quot;codePointAt()方法&quot;&gt;&lt;/a&gt;codePointAt()方法&lt;/h5&gt;&lt;p&gt;ES6新增完全支持UTF-16的方法，接
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>块级作用域绑定</title>
    <link href="https://www.github.com/qyg2019/2020/01/23/ES6-1/"/>
    <id>https://www.github.com/qyg2019/2020/01/23/ES6-1/</id>
    <published>2020-01-23T07:14:38.757Z</published>
    <updated>2020-01-23T07:13:39.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="var声明及变量提升（hoisting机制）"><a href="#var声明及变量提升（hoisting机制）" class="headerlink" title="var声明及变量提升（hoisting机制）"></a>var声明及变量提升（hoisting机制）</h3><p>在函数作用域或者全局作用域中通过<strong>var</strong>声明的变量，无论在哪里声明的，都会被当成是在当前作用域顶部声明的变量，这就是hoisting机制。ES6引入块级作用域来强化对变量生命周期的控制。</p><h3 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h3><p>块级声明在指定块的作用域之外无法访问的变量。</p><ul><li>函数内部</li><li>块中（{}之间的区域）</li></ul><h4 id="1-let声明"><a href="#1-let声明" class="headerlink" title="1.  let声明"></a>1.  let声明</h4><ul><li><p>用<strong>let</strong>来代替<strong>var</strong>声明变量，把变量的作用域限制在当前代码块，<strong>let</strong>声明不会被提升，当执行流离开当前块，变量会立刻被销毁。</p></li><li><p>禁止重声明</p><figure class="highlight plain"><figcaption><span>a</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;1;</span><br><span class="line">let a&#x3D;2;  &#x2F;&#x2F;抛出语法错误</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-const声明"><a href="#2-const声明" class="headerlink" title="2.  const声明"></a>2.  const声明</h4><ul><li><strong>const</strong>声明的是常量，其值一旦被设定后不可更改</li><li>使用<strong>const</strong>声明的常量必须初始化，常量同样不会被提升到作用域顶部</li><li>块外执行即刻被销毁</li><li>禁止重声明</li><li>const声明不允许修改绑定，但可以修改值，可以修改声明对象的值</li></ul><h3 id="临时死区（TDZ）"><a href="#临时死区（TDZ）" class="headerlink" title="临时死区（TDZ）"></a>临时死区（TDZ）</h3><p>JavaScript引擎在扫描代码发现变量声明时，要么将变量提升至作用域顶部，要么放到TDZ中访问TDZ中的变量会触发运行时错误。当执行过变量声明语句后，从TDZ中移出，然后才可正常访问。</p><h3 id="var与let，const全局作用域绑定的区别"><a href="#var与let，const全局作用域绑定的区别" class="headerlink" title="var与let，const全局作用域绑定的区别"></a>var与let，const全局作用域绑定的区别</h3><p>当<strong>var</strong>被用于全局作用域时，会创建一个新的全局变量作为全局对象window的属性，这可能会覆盖一个已经存在的全局变量。</p><p>使用<strong>let</strong>, <strong>const</strong>会在全局作用域下创建一个新的绑定，但不会添加为全局对象的属性，不能覆盖全局变量，只能遮盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;var声明及变量提升（hoisting机制）&quot;&gt;&lt;a href=&quot;#var声明及变量提升（hoisting机制）&quot; class=&quot;headerlink&quot; title=&quot;var声明及变量提升（hoisting机制）&quot;&gt;&lt;/a&gt;var声明及变量提升（hoisting机
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://www.github.com/qyg2019/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>vue实例的生命周期</title>
    <link href="https://www.github.com/qyg2019/2020/01/12/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.github.com/qyg2019/2020/01/12/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-01-12T04:50:36.899Z</published>
    <updated>2019-12-28T14:35:32.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VUE实例的生命周期"><a href="#VUE实例的生命周期" class="headerlink" title="VUE实例的生命周期"></a>VUE实例的生命周期</h3><hr><ul><li><p>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</p></li><li><p><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</p></li><li><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p></li></ul><h4 id="主要的生命周期函数分类："><a href="#主要的生命周期函数分类：" class="headerlink" title="主要的生命周期函数分类："></a>主要的生命周期函数分类：</h4><ul><li><p>创建期间的生命周期函数：</p><ul><li><p>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</p><ul><li><p>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</p></li><li><p>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</p></li><li><p>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</p></li></ul></li></ul></li></ul><ul><li><p>运行期间的生命周期函数：</p><ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点<ul><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul></li></ul></li></ul><ul><li>销毁期间的生命周期函数：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。<ul><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ul></li></ul><p><img src="/img/lifecycle.png" alt="生命周期"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;VUE实例的生命周期&quot;&gt;&lt;a href=&quot;#VUE实例的生命周期&quot; class=&quot;headerlink&quot; title=&quot;VUE实例的生命周期&quot;&gt;&lt;/a&gt;VUE实例的生命周期&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是生命周期：从Vue实例创建、运行、到销毁期
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack使用</title>
    <link href="https://www.github.com/qyg2019/2020/01/05/webpack/"/>
    <id>https://www.github.com/qyg2019/2020/01/05/webpack/</id>
    <published>2020-01-05T11:40:54.038Z</published>
    <updated>2019-12-28T14:25:59.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在网页中会引用哪些常见的静态资源？"><a href="#在网页中会引用哪些常见的静态资源？" class="headerlink" title="在网页中会引用哪些常见的静态资源？"></a>在网页中会引用哪些常见的静态资源？</h2><ul><li>JS<ul><li>.js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）</li></ul></li><li>CSS<ul><li>.css  .less   .sass  .scss</li></ul></li><li>Images<ul><li>.jpg   .png   .gif   .bmp   .svg</li></ul></li><li>字体文件（Fonts）<ul><li>.svg   .ttf   .eot   .woff   .woff2</li></ul></li><li>模板文件<ul><li>.ejs   .jade  .vue</li></ul></li></ul><h2 id="网页中引入的静态资源多了以后有什么问题？？？"><a href="#网页中引入的静态资源多了以后有什么问题？？？" class="headerlink" title="网页中引入的静态资源多了以后有什么问题？？？"></a>网页中引入的静态资源多了以后有什么问题？？？</h2><ol><li>网页加载速度慢， 因为 我们要发起很多的二次请求；</li><li>要处理错综复杂的依赖关系</li></ol><h2 id="如何解决上述两个问题"><a href="#如何解决上述两个问题" class="headerlink" title="如何解决上述两个问题"></a>如何解决上述两个问题</h2><ol><li>合并、压缩、精灵图、图片的Base64编码</li><li>可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；</li></ol><h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack?"></a>什么是webpack?</h2><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p><h2 id="如何完美实现上述的2种解决方案"><a href="#如何完美实现上述的2种解决方案" class="headerlink" title="如何完美实现上述的2种解决方案"></a>如何完美实现上述的2种解决方案</h2><ol><li>使用Gulp， 是基于 task 任务的；</li><li>使用Webpack， 是基于整个项目进行构建的；</li></ol><ul><li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li><li>根据官网的图片介绍webpack打包的过程</li></ul><h2 id="webpack安装的两种方式"><a href="#webpack安装的两种方式" class="headerlink" title="webpack安装的两种方式"></a>webpack安装的两种方式</h2><ol><li>运行<code>npm i webpack -g</code>全局安装webpack，这样就能在全局使用webpack的命令</li><li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中</li></ol><h2 id="初步使用webpack打包构建列表隔行变色案例"><a href="#初步使用webpack打包构建列表隔行变色案例" class="headerlink" title="初步使用webpack打包构建列表隔行变色案例"></a>初步使用webpack打包构建列表隔行变色案例</h2><ol><li>运行<code>npm init</code>初始化项目，使用npm管理项目中的依赖包</li><li>创建项目基本的目录结构</li><li>使用<code>cnpm i jquery --save</code>安装jquery类库</li><li>创建<code>main.js</code>并书写各行变色的代码逻辑：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入jquery类库</span><br><span class="line">   import $ from &#39;jquery&#39;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 设置偶数行背景色，索引从0开始，0是偶数</span><br><span class="line">   $(&#39;#list li:even&#39;).css(&#39;backgroundColor&#39;,&#39;lightblue&#39;);</span><br><span class="line">   &#x2F;&#x2F; 设置奇数行背景色</span><br><span class="line">   $(&#39;#list li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;);</span><br></pre></td></tr></table></figure></li><li>直接在页面上引用<code>main.js</code>会报错，因为浏览器不认识<code>import</code>这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；</li><li>运行<code>webpack 入口文件路径 输出文件路径</code>对<code>main.js</code>进行处理：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack src&#x2F;js&#x2F;main.js dist&#x2F;bundle.js</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack的配置文件简化打包时候的命令"><a href="#使用webpack的配置文件简化打包时候的命令" class="headerlink" title="使用webpack的配置文件简化打包时候的命令"></a>使用webpack的配置文件简化打包时候的命令</h2><ol><li>在项目根目录中创建<code>webpack.config.js</code></li><li>由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在<code>webpack.config.js</code>中配置这两个路径：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入处理路径的模块</span><br><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件</span><br><span class="line">    output: &#123; &#x2F;&#x2F; 配置输出选项</span><br><span class="line">        path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径</span><br><span class="line">        filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现webpack的实时打包构建"><a href="#实现webpack的实时打包构建" class="headerlink" title="实现webpack的实时打包构建"></a>实现webpack的实时打包构建</h2><ol><li>由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用<code>webpack-dev-server</code>来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</li><li>运行<code>cnpm i webpack-dev-server --save-dev</code>安装到开发依赖</li><li>安装完成之后，在命令行直接运行<code>webpack-dev-server</code>来进行打包，发现报错，此时需要借助于<code>package.json</code>文件中的指令，来进行运行<code>webpack-dev-server</code>命令，在<code>scripts</code>节点下新增<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>指令，发现可以进行实时打包，但是dist目录下并没有生成<code>bundle.js</code>文件，这是因为<code>webpack-dev-server</code>将打包好的文件放在了内存中<ul><li>把<code>bundle.js</code>放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</li><li>这个时候访问webpack-dev-server启动的<code>http://localhost:8080/</code>网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:<code>&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;</code></li><li>为了能在访问<code>http://localhost:8080/</code>的时候直接访问到index首页，可以使用<code>--contentBase src</code>指令来修改dev指令，指定启动的根目录：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot;</span><br></pre></td></tr></table></figure>同时修改index页面中script的src属性为<code>&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ol><h2 id="使用html-webpack-plugin插件配置启动页面"><a href="#使用html-webpack-plugin插件配置启动页面" class="headerlink" title="使用html-webpack-plugin插件配置启动页面"></a>使用<code>html-webpack-plugin</code>插件配置启动页面</h2><p>由于使用<code>--contentBase</code>指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用<code>html-webpack-plugin</code>插件配置启动页面.</p><ol><li>运行<code>cnpm i html-webpack-plugin --save-dev</code>安装到开发依赖</li><li>修改<code>webpack.config.js</code>配置文件如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入处理路径的模块</span><br><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line">&#x2F;&#x2F; 导入自动生成HTMl文件的插件</span><br><span class="line">var htmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件</span><br><span class="line">    output: &#123; &#x2F;&#x2F; 配置输出选项</span><br><span class="line">        path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径</span><br><span class="line">        filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[ &#x2F;&#x2F; 添加plugins节点配置插件</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.resolve(__dirname, &#39;src&#x2F;index.html&#39;),&#x2F;&#x2F;模板路径</span><br><span class="line">            filename:&#39;index.html&#39;&#x2F;&#x2F;自动生成的HTML文件的名称</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改<code>package.json</code>中<code>script</code>节点中的dev指令如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br></pre></td></tr></table></figure></li><li>将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把bundle.js注入到index.html页面中！</li></ol><h2 id="实现自动打开浏览器、热更新和配置浏览器的默认端口号"><a href="#实现自动打开浏览器、热更新和配置浏览器的默认端口号" class="headerlink" title="实现自动打开浏览器、热更新和配置浏览器的默认端口号"></a>实现自动打开浏览器、热更新和配置浏览器的默认端口号</h2><p><strong>注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！</strong></p><h3 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h3><ul><li>修改<code>package.json</code>的script节点如下，其中<code>--open</code>表示自动打开浏览器，<code>--port 4321</code>表示打开的端口号为4321，<code>--hot</code>表示启用浏览器热更新：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h3><ol><li>修改<code>webpack.config.js</code>文件，新增<code>devServer</code>节点如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">        hot:true,</span><br><span class="line">        open:true,</span><br><span class="line">        port:4321</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>在头部引入<code>webpack</code>模块：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var webpack &#x3D; require(&#39;webpack&#39;);</span><br></pre></td></tr></table></figure></li><li>在<code>plugins</code>节点下新增：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack打包css文件"><a href="#使用webpack打包css文件" class="headerlink" title="使用webpack打包css文件"></a>使用webpack打包css文件</h2><ol><li>运行<code>cnpm i style-loader css-loader --save-dev</code></li><li>修改<code>webpack.config.js</code>这个配置文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module: &#123; &#x2F;&#x2F; 用来配置第三方loader模块的</span><br><span class="line">        rules: [ &#x2F;&#x2F; 文件的匹配规则</span><br><span class="line">            &#123; test: &#x2F;\.css$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] &#125;&#x2F;&#x2F;处理css文件的规则</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>注意：<code>use</code>表示使用哪些模块来处理<code>test</code>所匹配到的文件；<code>use</code>中相关loader模块的调用顺序是从后向前调用的；</li></ol><h2 id="使用webpack打包less文件"><a href="#使用webpack打包less文件" class="headerlink" title="使用webpack打包less文件"></a>使用webpack打包less文件</h2><ol><li>运行<code>cnpm i less-loader less -D</code></li><li>修改<code>webpack.config.js</code>这个配置文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: &#x2F;\.less$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] &#125;,</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack打包sass文件"><a href="#使用webpack打包sass文件" class="headerlink" title="使用webpack打包sass文件"></a>使用webpack打包sass文件</h2><ol><li>运行<code>cnpm i sass-loader node-sass --save-dev</code></li><li>在<code>webpack.config.js</code>中添加处理sass文件的loader模块：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: &#x2F;\.scss$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用webpack处理css中的路径"><a href="#使用webpack处理css中的路径" class="headerlink" title="使用webpack处理css中的路径"></a>使用webpack处理css中的路径</h2><ol><li>运行<code>cnpm i url-loader file-loader --save-dev</code></li><li>在<code>webpack.config.js</code>中添加处理url路径的loader模块：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: &#x2F;\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader&#39; &#125;</span><br></pre></td></tr></table></figure></li><li>可以通过<code>limit</code>指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: &#x2F;\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader?limit&#x3D;43960&#39; &#125;,</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用babel处理高级JS语法"><a href="#使用babel处理高级JS语法" class="headerlink" title="使用babel处理高级JS语法"></a>使用babel处理高级JS语法</h2><ol><li>运行<code>cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev</code>安装babel的相关loader包</li><li>运行<code>cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev</code>安装babel转换的语法</li><li>在<code>webpack.config.js</code>中添加相关loader模块，其中需要注意的是，一定要把<code>node_modules</code>文件夹添加到排除项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: &#x2F;\.js$&#x2F;, use: &#39;babel-loader&#39;, exclude: &#x2F;node_modules&#x2F; &#125;</span><br></pre></td></tr></table></figure></li><li>在项目根目录中添加<code>.babelrc</code>文件，并修改这个配置文件如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;es2015&quot;, &quot;stage-0&quot;],</span><br><span class="line">    &quot;plugins&quot;:[&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>注意：语法插件<code>babel-preset-es2015</code>可以更新为<code>babel-preset-env</code>，它包含了所有的ES相关的语法；</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在网页中会引用哪些常见的静态资源？&quot;&gt;&lt;a href=&quot;#在网页中会引用哪些常见的静态资源？&quot; class=&quot;headerlink&quot; title=&quot;在网页中会引用哪些常见的静态资源？&quot;&gt;&lt;/a&gt;在网页中会引用哪些常见的静态资源？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JS&lt;u
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://www.github.com/qyg2019/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://www.github.com/qyg2019/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>图解MVVM与MVC</title>
    <link href="https://www.github.com/qyg2019/2020/01/05/%E5%9B%BE%E8%A7%A3MVVM%E4%B8%8EMVC/"/>
    <id>https://www.github.com/qyg2019/2020/01/05/%E5%9B%BE%E8%A7%A3MVVM%E4%B8%8EMVC/</id>
    <published>2020-01-05T11:40:54.038Z</published>
    <updated>2019-12-25T14:31:40.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MVC与MVVC"><a href="#MVC与MVVC" class="headerlink" title="MVC与MVVC"></a>MVC与MVVC</h3><h4 id="MVC-是一种使用-MVC（Model-View-Controller-模型-视图-控制器）设计创建-Web-应用程序的模式"><a href="#MVC-是一种使用-MVC（Model-View-Controller-模型-视图-控制器）设计创建-Web-应用程序的模式" class="headerlink" title="MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式"></a>MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式</h4><p>Model（模型）表示应用程序核心（比如数据库记录列表）。</p><p>View（视图）显示数据（数据库记录）。</p><p>Controller（控制器）处理输入（写入数据库记录）。</p><p>MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。<br>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。<br>　　通常模型对象负责在数据库中存取数据。<br>View（视图）是应用程序中处理数据显示的部分。<br>　　通常视图是依据模型数据创建的。<br>Controller（控制器）是应用程序中处理用户交互的部分。<br>　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>Model 模型<br>模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。</p><p>View 视图<br>就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。</p><p>ViewModel 视图模型<br>视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。<br><img src="/img/MVC.png" alt="MVC"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MVC与MVVC&quot;&gt;&lt;a href=&quot;#MVC与MVVC&quot; class=&quot;headerlink&quot; title=&quot;MVC与MVVC&quot;&gt;&lt;/a&gt;MVC与MVVC&lt;/h3&gt;&lt;h4 id=&quot;MVC-是一种使用-MVC（Model-View-Controller-模型-视图
      
    
    </summary>
    
    
      <category term="MVVM与MVC" scheme="https://www.github.com/qyg2019/categories/MVVM%E4%B8%8EMVC/"/>
    
    
      <category term="MVVM与MVC" scheme="https://www.github.com/qyg2019/tags/MVVM%E4%B8%8EMVC/"/>
    
  </entry>
  
  <entry>
    <title>vue组件的使用</title>
    <link href="https://www.github.com/qyg2019/2020/01/05/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.github.com/qyg2019/2020/01/05/%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-01-05T11:40:54.038Z</published>
    <updated>2019-12-28T14:35:49.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul><li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li><li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；</li></ul><h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><ol><li>使用 Vue.extend 配合 Vue.component 方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var login &#x3D; Vue.extend(&#123;</span><br><span class="line">      template: &#39;&lt;h1&gt;登录&lt;&#x2F;h1&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.component(&#39;login&#39;, login);</span><br></pre></td></tr></table></figure><ol><li>直接使用 Vue.component 方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;register&#39;, &#123;</span><br><span class="line">      template: &#39;&lt;h1&gt;注册&lt;&#x2F;h1&gt;&#39;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol><li>将模板字符串，定义到script标签种：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id&#x3D;&quot;tmpl&quot; type&#x3D;&quot;x-template&quot;&gt;</span><br><span class="line">      &lt;div&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;#&quot;&gt;注册&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>同时，需要使用 Vue.component 来定义组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;account&#39;, &#123;</span><br><span class="line">      template: &#39;#tmpl&#39;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p></blockquote><h3 id="组件中展示数据和响应事件"><a href="#组件中展示数据和响应事件" class="headerlink" title="组件中展示数据和响应事件"></a>组件中展示数据和响应事件</h3><ol><li>在组件中，<code>data</code>需要被定义为一个方法，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;account&#39;, &#123;</span><br><span class="line">      template: &#39;#tmpl&#39;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &#39;大家好！&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        login()&#123;</span><br><span class="line">          alert(&#39;点击了登录按钮&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol><li>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</li></ol><h3 id="为什么组件中的data属性必须定义为一个方法并返回一个对象"><a href="#为什么组件中的data属性必须定义为一个方法并返回一个对象" class="headerlink" title="为什么组件中的data属性必须定义为一个方法并返回一个对象"></a>为什么组件中的data属性必须定义为一个方法并返回一个对象</h3><p>保持一份单独的拷贝。</p><h3 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h3><ol><li>组件实例定义方式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">      el: &#39;#app&#39;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      components: &#123; &#x2F;&#x2F; 定义子组件</span><br><span class="line">        account: &#123; &#x2F;&#x2F; account 组件</span><br><span class="line">          template: &#39;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;&lt;login&gt;&lt;&#x2F;login&gt;&lt;&#x2F;div&gt;&#39;, &#x2F;&#x2F; 在这里使用定义的子组件</span><br><span class="line">          components: &#123; &#x2F;&#x2F; 定义子组件的子组件</span><br><span class="line">            login: &#123; &#x2F;&#x2F; login 组件</span><br><span class="line">              template: &quot;&lt;h3&gt;这是登录组件&lt;&#x2F;h3&gt;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ol><li>引用组件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;account&gt;&lt;&#x2F;account&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h2><ol><li>页面结构：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;toggle&quot; @click&#x3D;&quot;flag&#x3D;!flag&quot;&gt;</span><br><span class="line">    &lt;my-com1 v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com1&gt;</span><br><span class="line">    &lt;my-com2 v-else&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ol><li>Vue实例定义：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&#39;myCom1&#39;, &#123;</span><br><span class="line">      template: &#39;&lt;h3&gt;奔波霸&lt;&#x2F;h3&gt;&#39;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.component(&#39;myCom2&#39;, &#123;</span><br><span class="line">      template: &#39;&lt;h3&gt;霸波奔&lt;&#x2F;h3&gt;&#39;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">      el: &#39;#app&#39;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        flag: true</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-is属性来切换不同的子组件-并添加切换动画"><a href="#使用-is属性来切换不同的子组件-并添加切换动画" class="headerlink" title="使用:is属性来切换不同的子组件,并添加切换动画"></a>使用<code>:is</code>属性来切换不同的子组件,并添加切换动画</h2><ol><li>组件实例定义方式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 登录组件</span><br><span class="line">  const login &#x3D; Vue.extend(&#123;</span><br><span class="line">    template: &#96;&lt;div&gt;</span><br><span class="line">      &lt;h3&gt;登录组件&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;</span><br><span class="line">  &#125;);</span><br><span class="line">  Vue.component(&#39;login&#39;, login);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 注册组件</span><br><span class="line">  const register &#x3D; Vue.extend(&#123;</span><br><span class="line">    template: &#96;&lt;div&gt;</span><br><span class="line">      &lt;h3&gt;注册组件&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;</span><br><span class="line">  &#125;);</span><br><span class="line">  Vue.component(&#39;register&#39;, register);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class="line">  var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data: &#123; comName: &#39;login&#39; &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol><li>使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;login&#39;&quot;&gt;登录&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;register&#39;&quot;&gt;注册&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;transition mode&#x3D;&quot;out-in&quot;&gt;</span><br><span class="line">    &lt;component :is&#x3D;&quot;comName&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">  &lt;&#x2F;transition&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ol><li>添加切换样式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .v-enter,</span><br><span class="line">  .v-leave-to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateX(30px);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .v-enter-active,</span><br><span class="line">  .v-leave-active &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    transition: all 0.3s ease;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  h3&#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol><li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">      el: &#39;#app&#39;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &#39;这是父组件中的消息&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        son: &#123;</span><br><span class="line">          template: &#39;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;&#x2F;h1&gt;&#39;,</span><br><span class="line">          props: [&#39;finfo&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ol><li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;son :finfo&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol><li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li><li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;</span><br></pre></td></tr></table></figure><ol><li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 引用父组件 --&gt;</span><br><span class="line">    &lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 组件模板定义 --&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;x-template&quot; id&#x3D;&quot;son&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;向父组件传值&quot; @click&#x3D;&quot;sendMsg&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 子组件的定义方式</span><br><span class="line">    Vue.component(&#39;son&#39;, &#123;</span><br><span class="line">      template: &#39;#son&#39;, &#x2F;&#x2F; 组件模板Id</span><br><span class="line">      methods: &#123;</span><br><span class="line">        sendMsg() &#123; &#x2F;&#x2F; 按钮的点击事件</span><br><span class="line">          this.$emit(&#39;func&#39;, &#39;OK&#39;); &#x2F;&#x2F; 调用父组件传递过来的方法，同时把数据传递出去</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">      el: &#39;#app&#39;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        getMsg(val)&#123; &#x2F;&#x2F; 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span><br><span class="line">          alert(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义Vue组件&quot;&gt;&lt;a href=&quot;#定义Vue组件&quot; class=&quot;headerlink&quot; title=&quot;定义Vue组件&quot;&gt;&lt;/a&gt;定义Vue组件&lt;/h2&gt;&lt;p&gt;什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>配置Git</title>
    <link href="https://www.github.com/qyg2019/2020/01/05/%E9%85%8D%E7%BD%AEGit/"/>
    <id>https://www.github.com/qyg2019/2020/01/05/%E9%85%8D%E7%BD%AEGit/</id>
    <published>2020-01-05T11:40:54.038Z</published>
    <updated>2019-12-28T14:35:53.303Z</updated>
    
    <content type="html"><![CDATA[<p>为了设置Git中的配置值，需要使用config命令。</p><h3 id="告知Git你的身份"><a href="#告知Git你的身份" class="headerlink" title="告知Git你的身份"></a>告知Git你的身份</h3><p>这要根据用户名和电子邮件地址来确定，Git是一个源管理系统，它期望知道是谁在进行这些变更，以方便记录。</p><p>git config–global user.name <name></p><p>git config–global user.email <email address></p><p>实际上Git可以接受任何邮件地址，在设置时并不会对其进行验证，但是Git的一些高级功能可能会使用这个邮件地址，因此保证其正确性还是很有必要的。</p><h3 id="配置范围"><a href="#配置范围" class="headerlink" title="配置范围"></a>配置范围</h3><ol><li>system</li></ol><p>在系统级别配置意味着会被应用于指定机器上所有仓库。用config命令指定–system选项。</p><p>git config–system  <options></p><ol start="2"><li>global</li></ol><p>全局配置值适用于特定用户的所有仓库，这是用户适用最常见的级别。</p><p>git config–global  <options></p><ol start="3"><li>local</li></ol><p>该设置只用于一个仓库的上下文。</p><p>git config–local  <options></p><h3 id="设置的层次结构"><a href="#设置的层次结构" class="headerlink" title="设置的层次结构"></a>设置的层次结构</h3><p>首先会在本地仓库配置中查找，然后查找全局配置，最后查找系统配置。如果找到一个值，那么就是用这个值。 </p><ul><li><h4 id="查看配置值"><a href="#查看配置值" class="headerlink" title="查看配置值"></a>查看配置值</h4></li></ul><p>git config <setting></p><ul><li><h4 id="撤销配置值"><a href="#撤销配置值" class="headerlink" title="撤销配置值"></a>撤销配置值</h4></li></ul><p>git config –unset <options></p><ul><li><h4 id="列出配置值"><a href="#列出配置值" class="headerlink" title="列出配置值"></a>列出配置值</h4></li></ul><p>git config –list</p><p>包含但不限于本地，全局，系统，如果同时设置将会一起显示，为了避免混淆，可以指定范围。</p><p>git config –global –list</p><ul><li><h4 id="一次性配置"><a href="#一次性配置" class="headerlink" title="一次性配置"></a>一次性配置</h4></li></ul><p>git -c <setting>=<value>      类似于键值对的形式</p><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了设置Git中的配置值，需要使用config命令。&lt;/p&gt;
&lt;h3 id=&quot;告知Git你的身份&quot;&gt;&lt;a href=&quot;#告知Git你的身份&quot; class=&quot;headerlink&quot; title=&quot;告知Git你的身份&quot;&gt;&lt;/a&gt;告知Git你的身份&lt;/h3&gt;&lt;p&gt;这要根据用户名和
      
    
    </summary>
    
    
      <category term="Git" scheme="https://www.github.com/qyg2019/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.github.com/qyg2019/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>分布式版本控制系统Git常用命令浅谈</title>
    <link href="https://www.github.com/qyg2019/2020/01/05/git%E5%88%86%E5%B8%83%E5%BC%8F%E5%91%BD%E4%BB%A4%E6%B5%85%E8%B0%88/"/>
    <id>https://www.github.com/qyg2019/2020/01/05/git%E5%88%86%E5%B8%83%E5%BC%8F%E5%91%BD%E4%BB%A4%E6%B5%85%E8%B0%88/</id>
    <published>2020-01-05T11:40:54.022Z</published>
    <updated>2019-11-30T12:36:59.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Git-Git下载地址"><a href="#什么是Git-Git下载地址" class="headerlink" title="什么是Git                                                                                                                   Git下载地址"></a>什么是Git                                                                                                                   <a href="https://git-scm.com/" target="_blank" rel="noopener">Git下载地址</a></h4><p>Git是目前世界上最先进的分布式版本控制系统,具有备份， 记录操作时间线，多端共享代码（代替各种云盘的功能），‘自动’合并的功能。Git是没有中心服务器的，每个人机器上都是一个完整的库，我们平时开发代码时的中央服务器其实和我们自己机器上的库内容基本是完全一样的。</p><h4 id="Git原理及基本操作"><a href="#Git原理及基本操作" class="headerlink" title="Git原理及基本操作"></a>Git原理及基本操作</h4><p><img src="/img/git.png" alt="git原理"></p><p>本地仓库分为工作区、缓冲区以及仓库,每个仓库可以简单理解成一个目录，这个目录里面的所有文件都通过Git来实现版本管理，Git都能跟踪并记录在该目录中发生的所有更新。</p><h5 id="安装好Git后，新建一个文件夹，单击右键gitbush-输入以下命令初始化一个本地仓库："><a href="#安装好Git后，新建一个文件夹，单击右键gitbush-输入以下命令初始化一个本地仓库：" class="headerlink" title="安装好Git后，新建一个文件夹，单击右键gitbush,输入以下命令初始化一个本地仓库："></a>安装好Git后，新建一个文件夹，单击右键gitbush,输入以下命令初始化一个本地仓库：</h5><p><img src="/img/init.png" alt="init"></p><p>可以看到出现了一个文件夹：                        <img src="/img/gits.png" alt="gits"></p><p>接下来就可以在这个文件夹中进行开发了。</p><p>一顿苦逼的开发之后……</p><h5 id="使用add命令将指定文件或全部文件推入缓冲区"><a href="#使用add命令将指定文件或全部文件推入缓冲区" class="headerlink" title="使用add命令将指定文件或全部文件推入缓冲区"></a>使用add命令将指定文件或全部文件推入缓冲区</h5><p>​                                                                         <img src="/img/add.png" alt="add"></p><p>​                                                                         <img src="/img/addbf.png" alt="add部分文件"></p><h5 id="使用commit命令推入本地仓库"><a href="#使用commit命令推入本地仓库" class="headerlink" title="使用commit命令推入本地仓库"></a>使用commit命令推入本地仓库</h5><p>​                                                                          <img src="/img/commit.png" alt="commit"></p><p>  至此一个版本开发完毕，当然git还提供更多命令来供用户操作，一起来了解下吧！</p><p>   git status： 查看仓库当前的状态 </p><p>​   git diff +文件名：查看文件具体修改了哪里</p><p>​   git log：查看最近到最远提交到仓库的文件信息(一串数字为特有的时间序列id 可以根据它进行版本前后回滚)</p><p>   git reset –hard HEAD^：回退到上一次 commit的时候</p><p>   git reset –hard bdeacd: 版本前进 只能根据 id进行前进（id只写出前六位就好了）</p><p>   git reflog：查看每次操作仓库内的信息（commit）这样的话当黑窗口没了的时候，也可以查询具体操作信息，</p><p>   进行版本回退或者前进!</p><p>   git checkout – read.txt: 工作区恢复到最近一次的commit或者add</p><p>   git rm +文件名: 删除某一个文件</p><h5 id="需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。"><a href="#需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。" class="headerlink" title="需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。"></a>需要注意的是在开发尽量不要在master分支上进行，在开发完成后可以和master分支merge，因此会用到下列命令。</h5><p>   git branch dev: 创建dev分支</p><p>   git checkout dev： 切换到dev分支上开发</p><p>   git branch：查看所有分支</p><p>   git branch -d dev：删除分支 （-D 强制删除）</p><p>   git merge dev: 合并分支</p><h5 id="在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作："><a href="#在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作：" class="headerlink" title="在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和github关联，进行以下操作："></a>在实际的开发过程中往往是多人协作开发，这就需要把本地仓库和<a href="https://github.com/" target="_blank" rel="noopener">github</a>关联，进行以下操作：</h5><h5 id="1-首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）"><a href="#1-首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）" class="headerlink" title="1. 首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）"></a>1. 首先要再github上创建远程仓库用来存储项目，和本地电脑达成信任关系（ssh）</h5><h5 id="2-可以通过git-clone远程仓库（git-clone-git-github-com-HustCst-duyiApp-git）或者通过git-remote-add-origin-git-github-com-HustCst-duyiApp-git，是本地仓库和远程仓库相关联，git-pull-origin-master，本地才有master分支！"><a href="#2-可以通过git-clone远程仓库（git-clone-git-github-com-HustCst-duyiApp-git）或者通过git-remote-add-origin-git-github-com-HustCst-duyiApp-git，是本地仓库和远程仓库相关联，git-pull-origin-master，本地才有master分支！" class="headerlink" title="2.可以通过git clone远程仓库（git clone git@github.com:HustCst/duyiApp.git）或者通过git remote add origin git@github.com:HustCst/duyiApp.git，是本地仓库和远程仓库相关联，git pull origin master，本地才有master分支！"></a>2.可以通过git clone远程仓库（git clone <a href="mailto:git@github.com">git@github.com</a>:HustCst/duyiApp.git）或者通过git remote add origin <a href="mailto:git@github.com">git@github.com</a>:HustCst/duyiApp.git，是本地仓库和远程仓库相关联，git pull origin master，本地才有master分支！</h5><h5 id="3-之后再本地master分支上的代码上传到-远程仓库上的master分支-第一次上传使用-git-push-–u-origin-master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过-git-push-origin-master-–f-强行让master分支上的本地文件覆盖远程master分支上的文件）"><a href="#3-之后再本地master分支上的代码上传到-远程仓库上的master分支-第一次上传使用-git-push-–u-origin-master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过-git-push-origin-master-–f-强行让master分支上的本地文件覆盖远程master分支上的文件）" class="headerlink" title="3.之后再本地master分支上的代码上传到 远程仓库上的master分支 第一次上传使用 git push –u origin master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过 git push origin master –f 强行让master分支上的本地文件覆盖远程master分支上的文件）"></a>3.之后再本地master分支上的代码上传到 远程仓库上的master分支 第一次上传使用 git push –u origin master，之后可以简化命令，把-u去掉。（如果仓库里本身就有文件，但是我们不要了，而是想把远程的代码上传上去，我们可以通过 git push origin master –f 强行让master分支上的本地文件覆盖远程master分支上的文件）</h5><h2 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h2><p><strong>切记不要在本地master分支上开发，在其他分支如dev上开发后，合并到master上直接上传到 远程的 非master分支如dev分支，通过 git push origin master:dev; 之后项目参与者可以 new pull request 进行代码比对和阅读，项目管理人员在同意的情况下，会把远程dev分支上的东西合并到远程master分支上。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Git-Git下载地址&quot;&gt;&lt;a href=&quot;#什么是Git-Git下载地址&quot; class=&quot;headerlink&quot; title=&quot;什么是Git                                                          
      
    
    </summary>
    
    
      <category term="Git" scheme="https://www.github.com/qyg2019/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.github.com/qyg2019/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>vue-resource的使用</title>
    <link href="https://www.github.com/qyg2019/2020/01/05/vue-resource/"/>
    <id>https://www.github.com/qyg2019/2020/01/05/vue-resource/</id>
    <published>2020-01-05T11:40:54.022Z</published>
    <updated>2019-12-28T14:35:01.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-resource的使用"><a href="#vue-resource的使用" class="headerlink" title="vue-resource的使用"></a>vue-resource的使用</h3><hr><p>Vue 要实现异步加载需要使用到 vue-resource 库。</p><p>Vue.js 2.0 版本推荐使用 <a href="https://www.runoob.com/vue2/vuejs-ajax-axios.html" target="_blank" rel="noopener">axios</a> 来完成 ajax 请求。</p><h4 id="vue-resource-的配置步骤："><a href="#vue-resource-的配置步骤：" class="headerlink" title="vue-resource 的配置步骤："></a>vue-resource 的配置步骤：</h4><ul><li>直接在页面中，通过<code>script</code>标签，引入 <code>vue-resource</code> 的脚本文件；</li><li>注意：引用的先后顺序是：先引用 <code>Vue</code> 的脚本文件，再引用 <code>vue-resource</code> 的脚本文件；</li></ul><h4 id="常见的请求：get-post-jsonp"><a href="#常见的请求：get-post-jsonp" class="headerlink" title="常见的请求：get post jsonp"></a>常见的请求：get post jsonp</h4><p>​                                                                            get请求</p><p> this.$http.get(url).then( function(res){}, function(err){} )</p><p><img src="/img/get.png" alt=""></p><p>​                                                                            post请求</p><p>this.$http.post( url, {}, { emulateJSON: true }).then( function(res){}, function(err){} )</p><p><img src="/img/post.png" alt=""></p><p>​                                                                             jsonp请求</p><p>this.$http.jsonp(url).then( function(res){}, function(err){} )</p><p><img src="/img/jsonp.png" alt=""></p><h4 id="注：post-发送数据到后端，需要第三个参数-emulateJSON-true-。"><a href="#注：post-发送数据到后端，需要第三个参数-emulateJSON-true-。" class="headerlink" title="注：post 发送数据到后端，需要第三个参数 {emulateJSON:true}  。"></a>注：post 发送数据到后端，需要第三个参数 {emulateJSON:true}  。</h4><p>vue-resource共提供七种请求方法</p><p><img src="/img/rem.png" alt=""></p><p>参数说明：</p><p>​                                                                            <img src="/img/option.png" alt=""></p><p>处理响应的方法：</p><p><img src="/img/deal.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue-resource的使用&quot;&gt;&lt;a href=&quot;#vue-resource的使用&quot; class=&quot;headerlink&quot; title=&quot;vue-resource的使用&quot;&gt;&lt;/a&gt;vue-resource的使用&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;Vue 要实现异步加载需要
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue指令学习</title>
    <link href="https://www.github.com/qyg2019/2020/01/05/vue%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.github.com/qyg2019/2020/01/05/vue%E6%8C%87%E4%BB%A4/</id>
    <published>2020-01-05T11:40:54.022Z</published>
    <updated>2019-12-28T14:35:17.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><ul><li><p>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</p><ul><li>node 中的 express；</li></ul></li><li><p>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</p><ul><li><ol><li>从Jquery 切换到 Zepto</li></ol></li><li><ol start="2"><li>从 EJS 切换到 art-template</li></ol></li></ul></li></ul><h2 id="Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别"><a href="#Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别" class="headerlink" title="Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别"></a>Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</h2><ul><li><p>MVC 是后端的分层开发概念；</p></li><li><p>MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</p></li><li><p>为什么有了MVC还要有MVVM</p></li></ul><h2 id="Vue之-基本的代码结构和插值表达式、v-cloak"><a href="#Vue之-基本的代码结构和插值表达式、v-cloak" class="headerlink" title="Vue之 - 基本的代码结构和插值表达式、v-cloak"></a>Vue之 - <code>基本的代码结构</code>和<code>插值表达式</code>、<code>v-cloak</code></h2><h2 id="Vue指令之v-text和v-html"><a href="#Vue指令之v-text和v-html" class="headerlink" title="Vue指令之v-text和v-html"></a>Vue指令之<code>v-text</code>和<code>v-html</code></h2><p>v-text会覆盖元素中原本的内容，但是 插值表达式  只会替换自己的这个占位符，不会把 整个元素的内容清空</p><h2 id="Vue指令之v-bind的三种用法"><a href="#Vue指令之v-bind的三种用法" class="headerlink" title="Vue指令之v-bind的三种用法"></a>Vue指令之<code>v-bind</code>的三种用法</h2><ol><li><p>直接使用指令<code>v-bind</code></p></li><li><p>使用简化指令<code>:</code></p></li><li><p>在绑定的时候，拼接绑定内容：<code>:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot;</code></p></li></ol><h2 id="Vue指令之v-on的缩写和事件修饰符"><a href="#Vue指令之v-on的缩写和事件修饰符" class="headerlink" title="Vue指令之v-on的缩写和事件修饰符"></a>Vue指令之<code>v-on的缩写</code>和<code>事件修饰符</code></h2><h3 id="事件修饰符："><a href="#事件修饰符：" class="headerlink" title="事件修饰符："></a>事件修饰符：</h3><ul><li><p>.stop       阻止冒泡</p></li><li><p>.prevent    阻止默认事件</p></li><li><p>.capture    添加事件侦听器时使用事件捕获模式</p></li><li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p></li><li><p>.once       事件只触发一次</p></li></ul><h2 id="Vue指令之v-model和双向数据绑定"><a href="#Vue指令之v-model和双向数据绑定" class="headerlink" title="Vue指令之v-model和双向数据绑定"></a>Vue指令之<code>v-model</code>和<code>双向数据绑定</code></h2><p>v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定</p><p>使用  v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定</p><p>注意： v-model 只能运用在 表单元素中</p><h2 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h2><h3 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h3><ol><li><p>数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>数组中使用三元表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>数组中嵌套对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>直接使用对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class&#x3D;&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><ol><li><p>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style&#x3D;&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</p><ul><li>在data上定义样式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">        h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style&#x3D;&quot;h1StyleObj&quot;&gt;这是H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</p><ul><li>在data上定义样式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">        h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;,</span><br><span class="line">        h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style&#x3D;&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Vue指令之v-for和key属性"><a href="#Vue指令之v-for和key属性" class="headerlink" title="Vue指令之v-for和key属性"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h2><ol><li>迭代数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>迭代对象中的属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 循环遍历对象身上的属性 --&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div v-for&#x3D;&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>迭代数字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;p v-for&#x3D;&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p></blockquote><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p><h2 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><p>v-if 的特点：每次都会重新删除或创建元素</p><p>v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式</p><p>v-if 有较高的切换性能消耗<br>v-show 有较高的初始渲染消耗</p><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;框架和库的区别&quot;&gt;&lt;a href=&quot;#框架和库的区别&quot; class=&quot;headerlink&quot; title=&quot;框架和库的区别&quot;&gt;&lt;/a&gt;框架和库的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.github.com/qyg2019/tags/Vue/"/>
    
  </entry>
  
</feed>
